% FUNCTION [...] = gf_cont_struct_get(cont_struct CS, [operation [, args]])
%
%   General function for querying information about cont_struct objects and for
%   applying them to numerical continuation.
%   
%
%   * h = gf_cont_struct_get(cont_struct CS, 'init step size')
%   Return an initial step size for continuation.
%
%   * h = gf_cont_struct_get(cont_struct CS, 'min step size')
%   Return the minimum step size for continuation.
%
%   * h = gf_cont_struct_get(cont_struct CS, 'max step size')
%   Return the maximum step size for continuation.
%
%   * h = gf_cont_struct_get(cont_struct CS, 'step size decrement')
%   Return the decrement ratio of the step size for continuation.
%
%   * h = gf_cont_struct_get(cont_struct CS, 'step size increment')
%   Return the increment ratio of the step size for continuation.
%
%   * [vec tangent_sol, scalar tangent_par] = gf_cont_struct_get(cont_struct CS, 'compute tangent', vec solution, scalar parameter, vec tangent_sol, scalar tangent_par)
%   Compute and return an updated tangent.
%
%   * E = gf_cont_struct_get(cont_struct CS, 'init Moore-Penrose continuation', vec solution, scalar parameter, scalar init_dir)
%   Initialise the Moore-Penrose continuation: Return a unit tangent to
%   the solution curve at the point given by `solution` and `parameter`,
%   and an initial step size for the continuation. Orientation of the
%   computed tangent with respect to the parameter is determined by the
%   sign of `init_dir`.
%
%   * E = gf_cont_struct_get(cont_struct CS, 'Moore-Penrose continuation', vec solution, scalar parameter, vec tangent_sol, scalar tangent_par, scalar h)
%   Compute one step of the Moore-Penrose continuation: Take the point
%   given by `solution` and `parameter`, the tangent given by `tangent_sol`
%   and `tangent_par`, and the step size `h`. Return a new point on the
%   solution curve, the corresponding tangent, a step size for the next
%   step and optionally the current step size. If the returned step
%   size equals zero, the continuation has failed. Optionally, return
%   the type of any detected singular point.
%   NOTE: The new point need not to be saved in the model in the end!
%
%   * t = gf_cont_struct_get(cont_struct CS, 'non-smooth bifurcation test', vec solution1, scalar parameter1, vec tangent_sol1, scalar tangent_par1, vec solution2, scalar parameter2, vec tangent_sol2, scalar tangent_par2)
%   Test for a non-smooth bifurcation point between the point given by
%   `solution1` and `parameter1` with the tangent given by `tangent_sol1`
%   and `tangent_par1` and the point given by `solution2` and `parameter2`
%   with the tangent given by `tangent_sol2` and `tangent_par2`.
%
%   * t = gf_cont_struct_get(cont_struct CS, 'bifurcation test function')
%   Return the last value of the bifurcation test function and eventaully
%   the whole calculated graph when passing between different sub-domains
%   of differentiability.
%
%   * {X, gamma, T_X, T_gamma} = gf_cont_struct_get(cont_struct CS, 'sing_data')
%   Return a singular point (`X`, `gamma`) stored in the cont_struct object and a
%   couple of arrays (`T_X`, `T_gamma`) of tangents to all located solution
%   branches that emanate from there.
%
%   * s = gf_cont_struct_get(cont_struct CS, 'char')
%   Output a (unique) string representation of the cont_struct.
%   
%   This can be used for performing comparisons between two
%   different cont_struct objects.
%   This function is to be completed.
%   
%
%   * gf_cont_struct_get(cont_struct CS, 'display')
%   Display a short summary for a cont_struct object.
%
%
function [varargout]=gf_cont_struct_get(varargin)
  if (nargout),
    [varargout{1:nargout}]=gf_octave('cont_struct_get', varargin{:});
  else
    gf_octave('cont_struct_get', varargin{:});
    if (exist('ans', 'var') == 1), varargout{1}=ans; end;
  end;
% autogenerated mfile;
