\documentclass[11pt,a4paper]{article}
% allow both latex and PDFlatex compatibility  (from pdfTeX FAQ)
\usepackage{hyperlatex}

\usepackage{pifont}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{psfig}
\usepackage{array}
\usepackage{supertabular}
%\usepackage{fancyheadings}
\usepackage{here}
\usepackage{eepic,epic}
%\usepackage{pslatex} % devrait corriger le pb de fontes dans les pdfs mais le fichier produit n'est pas beau
\usepackage[english]{babel}
\usepackage{alltt}
\usepackage[english]{babel}
% \usepackage{textcomp]


\texonly{\newcommand{\tilda}{{$_{\widetilde{\ }}$}}}
%\texonly{\newcommand{\tilda}{{\荑繇祜铎茴鬻泔眄犷潲荇殪溽荟弪猥荇屮镱禊荃箦疳汶徵妍珧狃栝泺荃箦疳汶徵妍磲脲殇荃箦疳汶徵遨痄骠屮疳珏犷汨矧紧蝓瀣棂疱蜷钿屮紧蝓瀣疳珏忉汶蝈娼趄蹂痄骅殓桁殓梏蒋犀痄驷豸栾蚪裒弩义钺蜾蓰棂疱蝌彐ヰ秕戾痄荃箦疳汶徵妍箴徙妪轭箦蝈躅弩疳沐箝铄沐篌衢蝈荃箦疳汶徵妍躅溴蝮泔蝈茴鬻泔眄犷潲茕簖茕轶痨狴篝戾茱滗箝溴磲蜱轭爱广苠鲥铙殇屙狎玳爱广荇镳磲蜱轭伯点荇屮翳彘玷泊沩荇屮赭殇翳狈躲荑遽滂彘玷碑般茼犭彘钿屮茉茴鬻泔眄犷潲芤邋忑茯绍梵疳沐爱钡屙引茏茴鬻泔眄犷潲芤邋忑荑繇祗睇蝈犰茉茴鬻泔眄犷潲茕簖茕轶痨狴篝戾茏茴鬻泔眄犷潲茕簖茴鬻泔眄犷潲芷蜥泯鄄蓰茕苕蜥沱茕１茕２茉茴鬻泔眄犷潲荛沌蜥痂殂鄢荛钽祯溴珧狃栝泱埙殇翳剑陛２痄纨茏茴鬻泔眄犷潲荛沌蜥痂殂鄢荑繇扉礴２痤琮３茉茴鬻泔眄犷潲苠聃狒郾茆彗轭羼踽糸镱１苠钿羼踽糸镱茏茴鬻泔眄犷潲苠聃狒郾茆彗轭沐铘弪１苠钿沐铘弪茏轶羼蹰鲠戾铘麸荑繇祜铎茏茴鬻泔眄犷潲苋禅摄镱簖ボ荃箦疳汶徵妍骝犴弩钺鲩玑糸镱疳铄茏荑繇熹轵邈麸蝙珏翩屙唣蝻赍泗茏荑繇祛犴妍珏翩屙唣蝻赍泗茏荏弭泔躅翦螓梏盱溴痿椠昌茏荏弭泔躅翦螓梏盱狨麸礤铛昌茏茯孱鬻泔眄犷潲苋禅湾翎茗盱团粤溴筱蜷痿轱罱㈢弭驽慝躞弪磲铛犰荑繇祜铎荑繇祓犷屐骈屐潲深溴珏翩屙唣蝻赍泗荑繇煦篌滹泱豉戾泱簖茴鬻泔眄犷潲荇屮酏郾蓰茼狒栩睇１茴鬻泔眄犷潲茏怕鄄蓰茗扉铍２１茴鬻泔眄犷潲茴徕灬荑繇祗睇钺忪猃蝈钺礤茗盱孱怡灬篝弩鲥蝮轱镦棂疱蜢狒屮茴鬻泔眄犷潲苠祆荑繇祗睇翎觚茴鬻泔眄犷潲莒犴怃猃荑繇祗睇灬礅溽茴鬻泔眄犷潲荟狎屦箝祜铨荑繇祗睇屦箝祜铨茴鬻泔眄犷潲莛栝荑繇祗睇痂辇茴鬻泔眄犷潲荟狎痂辇荑繇祗睇痂辇茴鬻泔眄犷潲莛箝荑繇祗睇痼辇茴鬻泔眄犷潲荏殓磲荑繇祗睇箝珥猃茴鬻泔眄犷潲茴觚荑繇祗睇铛茴鬻泔眄犷潲茆弭猃荑繇祗睇忮翎茴鬻泔眄犷潲茜犴磲荑繇祗睇玑眄猃茴鬻泔眄犷潲茚祓栳荑繇祗睇犰痂猃茴鬻泔眄犷潲芮犴磲荑繇祗睇轻眄猃茴鬻泔眄犷潲苣屐翎荑繇祗睇腻祠猃茴鬻泔眄犷潲茕屐翎荑繇祗睇溴祠猃茴鬻泔眄犷潲芟礤玑荑繇祗睇享彗猃茴鬻泔眄犷潲茱礤玑荑繇祗睇镯彗猃茴鬻泔眄犷潲茱糸礤簖荑繇祗睇雉轫弩茴鬻泔眄犷潲莛蝻潺荑繇祗睇虚茴鬻泔眄犷潲荇狨荑繇祗睇翎觚茴鬻泔眄犷潲莛狎糸犰荑繇祗睇疳螋茴鬻泔眄犷潲荏蹴荑繇祗睇篚睚茴鬻泔眄犷潲荏踱箦酏荑繇祗睇篚恺茴鬻泔眄犷潲荛铘芴狎珏荑繇祗睇轭酏茴鬻泔眄犷潲荇殪潺
}
\texonly{
  \newcommand{\WEB}[2]{\href{#1}{#2}}
}
\T \newcommand{\Div}{\textrm{div}}
\W \newcommand{\Div}{div}
\T \newcommand{\Grad}{\textrm{grad}}
\W \newcommand{\Grad}{grad}
\T \newcommand{\Rot}{\textrm{curl}}
\W \newcommand{\Rot}{curl}

\W \newcommand{\gf}{Getfem\mbox{++}\hspace{0.01em}}
\T \newcommand{\gf}{{\sc Getfem++}\xspace}
\W \newcommand{\gmm}{Gmm\mbox{++}\hspace{0.01em}}
\T \newcommand{\gmm}{{\sc Gmm++}\xspace}

\W \newcommand{\newpage}{}
\W \newcommand{\hspace}[1]{ }
\W \newcommand{\left}{} % pour les left\(i\right) 
\W \newcommand{\right}{}
\W \newenvironment{alltt}{\begin{example}}{\end{example}}
\T \newenvironment{cppcode}{\begin{alltt}}{\end{alltt}}
\W \newenvironment{cppcode}{\begin{rawxml}<div class="cppcode">\end{rawxml}\begin{example}}{\end{example}\begin{rawxml}</div>\end{rawxml}}

\T \newcommand{\cpp}[1]{\texttt{#1}}
\T \newcommand{\filename}[1]{\texttt{#1}}

%doxfilename and doxref : used by doxygenlinks.tex
\T \newcommand{\doxfilename}[2]{\texttt{#1}}
\T \newcommand{\doxref}[2]{\cpp{#1}}

\W \newcommand{\cpp}[1]{\xmlattributes*{tt}{class="inlinecppcode"}\texttt{#1}}
\W \newcommand{\filename}[1]{\xmlattributes*{tt}{style="color:red"}\texttt{#1}}
\W \newcommand{\doxfilename}[2]{\xmlattributes*{tt}{class="inlinecppcode"}\texttt{\WEB{../getfem_reference/#2.html}{#1}}\xspace}
\W \newcommand{\doxref}[2]{\xmlattributes*{tt}{class="inlinecppcode"}\texttt{\WEB{../getfem_reference/#2.html}{#1}}\xspace}

\T \newenvironment{ctableau}[2]{\begin{center}\begin{supertabular}{#1}}{\end{supertabular}\end{center}}
\W \newenvironment{ctableau}[2]{\xmlattributes*{table}{border=1 align="center"}\begin{tabular}{#2}}{\end{tabular}}

\newcommand{\WEBB}[1]{\WEB{#1}{#1}}

\texonly{
  \newcommand{\femtab}[9]{
    \begin{center}
      \begin{tabular}{m{17cm}}
      \begin{tabular}{|m{16.109cm}|} \hline
        {\bf #1}\\
        {\tt #2} 
      \end{tabular} \\ \vspace{-0.12em} 
      \begin{tabular}{|m{2cm}|m{2cm}|m{2.5cm}|m{1.5cm}|m{1.5cm}|m{2cm}|m{2cm}|} \hline 
        Degree & dimension & d.o.f. number & class & vectorial & \mbox{$\tau$-equivalent} & Polynomial \\ \hline
        #3 & #4 & #5 & #6 & #7 & #8 & #9 \\ \hline
      \end{tabular}
    \end{tabular}
  \end{center}
  }
}

\htmlonly{
  \newcommand{\femtab}[9]{
    \\\\
    \begin{center}
      \begin{ctableau}{|m{16.109cm}|}{c} \hline
        {\bf #1}\\
        {\tt #2} 
      \end{ctableau}
      \begin{ctableau}{|m{2cm}|m{2cm}|m{2.5cm}|m{1.5cm}|m{1.5cm}|m{2cm}|m{2cm}|}{lllllll} \hline 
        Degree & dimension & d.o.f. number & class & vectorial & \mbox{$\tau$-equivalent} & Polynomial \\ \hline
         #3 & #4 & #5 & #6 & #7 & #8 & #9
      \end{ctableau}
      \\
    \end{center}
  }
}

% macros for linking filenames and classnames to the doxygen doc of getfem
% (i.e. \getfemmeshh \dalbitvector etc.) 
% edit updatedoxlinks.py to add new types/files
\input{doxygenlinks.tex}



\begin{document}
\htmltitle{Getfem Project}
\htmlpanel{0}%disable navigation panel

\begin{center}
\texonly{
  \includegraphics[width=10cm,angle=0]{logogetfemwhitebg}\\[0.2cm]
  a Generic Finite Element library in C++ \\[0.5cm]
  {\LARGE Documentation, part \Huge 1} \\[0.5cm]
  \fbox{\Huge \sc Description of the project} \\[0.5cm]
  { \large Yves {\sc Renard}, Julien {\sc Pommier} \footnote{ \it ICJ - CNRS UMR 5208, INSA de Lyon, 20, rue Albert Einstein, 69621 Villeurbanne Cedex, FRANCE, Yves.Renard@insa-lyon.fr } } \\[1.0cm]
  \today \\[2cm]
}
\htmlonly{
  \xlink{\htmlimg{logogetfem.png}{The Getfem++ logo}}{http://home.gna.org/getfem/}\\[2cm]
  a Generic Finite Element library in C++ \par\par
  {\LARGE Documentation, part \Huge 1} \\ \par\par
  {\Huge Description of the project } \\ \par
  { \large \xlink{Yves Renard}{mailto:Yves.Renard@insa-lyon.fr}, \xlink{Julien Pommier}{mailto:Julien.Pommier@insa-toulouse.fr}}\\
  {\it ICJ - CNRS UMR 5208, INSA de Lyon, 20, rue Albert Einstein, 69621 Villeurbanne Cedex, FRANCE.}\\
  \today \par\par
}
\end{center}

% \begin{abstract}
% Basic user documentation for \gf .
% \end{abstract}
\htmlonly{\\\\\\}
\texonly{\\[4cm]}
\begin{quote}
\input{../license.tex}
\end{quote}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          INTRODUCTION                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

The \gf project focuses on the development of a generic finite element library.
The goal is to provide a finite element framework which allows to easily build  numerical code for the modelisation of system described by partial differential equations (p.d.e.). A special attention is paid to the flexibility of the use of the library in the sense that the switch from a method offered by the library to another is made as easy as possible.

The major point allowing this, compared to traditional finite element codes, is the complete separation between the description of p.d.e. models and finite element methods. Moreover, a separation is made between integration methods (exact or approximated), geometric transformations (linear or not) and finite element methods of arbitrary degrees described on a reference element. \gf can be used to build very general finite elements codes, where the finite elements, integration methods, dimension of the meshes, are just some parameters that can be changed very easily, thus allowing a large spectrum of experimentations. Numerous examples are available in the \filename{tests} directory of the distribution.

The goal is also to make the addition of new finite element method as simple as possible. For standard method, a description of the finite element shape functions and the type of connection of degrees of freedom on the reference element is sufficient. Extensions are provided for Hermite elements, piecewise polynomial, non-polynomial, vectorial elements and XFem. Examples of predefined available methods are Pk on simplices in arbitrary degrees and dimensions, Qk on parallelepipeds, P1, P2 with bubble functions, Hermite elements, elements with hierarchic basis (for multigrid methods for instance), discontinuous Pk or Qk, XFem, Argyris, HCT, Raviart-Thomas.

The library also includes the usual tools for finite elements such as assembly procedures for classical PDEs, interpolation methods, computation of norms, mesh operations, boundary conditions, post-processing tools such as extraction of slices from a mesh ...

\gf has no meshing capabilities (apart regular meshes, and a not exploitable attempt), hence, in many situations, it is necessary to import meshes. Imports formats currently known by getfem are GiD , GmSH and emc2 mesh files. However, given a mesh, it is possible to refine it automatically.

The aim of the \gf project is not to provide a ready to use finite element code allowing for instance structural mechanics computations with a graphic interface. It is basically a library allowing the build of C++ finite element codes. However, the matlab and python interfaces allows to easily build application coupling the definition of the problem, the finite element methods selection and the graphical post-processing.

The future of the project is to continue to develop the finite element framework, focusing on the following points.
\begin{itemize}
  \item Background consolidation of the existing modules (with a reflection on the optimal representation of meshes, degrees of freedom, finite element methods ...).
  \item Developpement of innovating methods.
  \item Reflection on the optimal way to represent complex p.d.e. models with the maximum of flexibility and reusability. The brick system is a first step in this direction.
\end{itemize}

The vocation of \gf is to remain a free open source project. The advantage given by the fact to be an open source project is that by proposing a free use, one profits from the experiments of the users who by their tests and the difficulties or bug which they meet make progress the robustness of the algorithms. One also profits from the possible contributions of the users who can find interest to develop new functinalities within the proposed framework. That allows constructive exchanges which clarify the weak points and the strong points of the project.


\newpage
\tableofcontents
\newpage

\section{Diagram of the library}

This section describes the diagram of the different modules of the \gf library.
The current state and perspective for each module is described in section \ref{sec:descmod}.


\begin{figure}[H]
  \begin{center}
    \icgraphic{0.9\linewidth}{diagram}{Diagram of \gf}
  \end{center}
  \caption{ \it Diagram of \gf}
  \label{fig:elemf}
\end{figure}

\newpage



\section{Introduction to the fem description in \gf}

The aim of this section is to briefly introduce the fem description in \gf mainly in order to fix the notation used in the rest of the document (definition of element, reference element, geometric transformation, gradient of the geometric transformation ...).


\subsection{Convex structures}

Finite element methods are defined on small convex domains called elements. The simplest element on which a finite element method can be defined is a segment (simplex of dimension 1), other possibilities are triangles, tetrahedrons (simplices of dimension 2 and 3), prisms, parallelepiped ...
In \gf, a type of element (for us, a convex) is described by the object \cpp{bgeot::convex\_structure} defined in the file \cpp{bgeot\_convex\_structure.h}.\\[0.5cm]
It describes only the structure of the convex not the coordinates of the vertices.
This structure is not to be manipulated by itself, because it is not necessary that more than one structure of this type describe the same type of convex. What will be manipulated is a pointer on such a descriptor which has to be declared with the type \cpp{bgeot::pconvex\_structure} \\ \\

The following functions give a pointer onto the descriptor of the usual type of elements:

\begin{center} \begin{ctableau}{|m{0.45\linewidth}|m{0.5\linewidth}|}{ll} \hline
 \cpp{bgeot::simplex\_structure(dim\_type d)} & description of a simplex of dimension \cpp{d}. \\ \hline
 \cpp{bgeot::parallelepiped\_structure(dim\_type\;d)} &  description of a parallelepiped of dimension \cpp{d}. \\ \hline
 \cpp{bgeot::convex\_product\_structure( bgeot::pconvex\_structure p1, bgeot::pconvex\_structure p2) } & description of the direct product of \cpp{p1} and \cpp{p2}.\\ \hline
 \cpp{bgeot::prism\_structure(dim\_type d)}  & description of a prism of dimension \cpp{d}  \texonly{\\ \hline}
\end{ctableau} \end{center}

For instance if one needs the description of a square, one can call equivalently\\
\cpp{p = bgeot::parallelepiped\_structure(2); }
or\\
\cpp{p = bgeot::convex\_product\_structure(bgeot::simplex\_structure(1),\\         \hspace{18.5em} bgeot::simplex\_structure(1)); }\\

The descriptor contains in particular  the number of faces (\cpp{p->nb\_faces()}), the dimension of the convex (\cpp{p->dim()}), for the number of vertices (\cpp{p->nb\_points()}). Other information is the number of vertices of each face, the description of a face and the eventual reference to a more basic description (used for the description of geometric transformations).

\htmlonly{\label{fig:elem}}
\begin{figure}[H]
  \begin{center}
    \icgraphic{10cm}{getfemelemelem}{usual elements}
  \end{center}
  \caption{ \it Usual elements. }
  \texonly{\label{fig:elem}}
\end{figure}


\subsection{Convexes of reference}

A convex of reference is a particular real element, i.e. a structure of convex with a list of vertices. It describes the particular element from which a finite element method is defined. In the file \cpp{bgeot\_convex\_ref.h} the object\\[0.5cm]
\cpp{bgeot::convex\_of\_reference }\\[0.5cm]
makes this description. The library keeps only one  description for each type of convex. So what will be manipulated is a pointer of type \cpp{bgeot::pconvex\_ref } on the descriptor\\[0.5cm]

The following functions build the descriptions:

\begin{center} \begin{ctableau}{|m{0.55\linewidth}|m{0.4\linewidth}|}{ll} \hline
\cpp{bgeot::simplex\_of\_reference(dim\_type d)} & description of the simplex of reference of dimension \cpp{d} \\ \hline
  
  \cpp{bgeot::simplex\_of\_reference(dim\_type d, short\_type k)} & description of the simplex of reference of dimension \cpp{d} with degree \cpp{k} Lagrange grid. \\ \hline

  \cpp{bgeot::convex\_ref\_product(pconvex\_ref a, pconvex\_ref b)} & description of the direct product of two convexes of reference.\\ \hline
  
  \cpp{bgeot::parallelepiped\_of\_reference(dim\_type\;d)} & description of the parallelepiped of reference of dimension \cpp{d}   \texonly{\\ \hline}
\end{ctableau} \end{center}

The vertices correspond to the classical vertices for such reference element. For instance the vertices for the triangle are $(0, 0), (1, 0)$ and $(0, 1)$. It corresponds to the configuration shown in Figure \ref{fig:elem}

If \cpp{p} is of type \cpp{bgeot::pconvex\_ref } then \cpp{p->structure()} is the corresponding convex structure. Thus for instance \cpp{p->structure()->nb\_points()} gives the number of vertices. The function \cpp{p->points()} give the array of vertices and \cpp{p->points()[0]} is the first vertex. The function \cpp{p->is\_in(const base\_node \&pt)} return a real which is negative if the point \cpp{pt} is in the element. The function \cpp{p->is\_in\_face(short\_type f, const base\_node \&pt)} return a real which is null if the point \cpp{pt} is in the face \cpp{k} of the element. Other functions can be found in \cpp{bgeot\_convex\_ref.h} and \cpp{bgeot\_convex.h}.

\subsection{Shape function type}

Most of the time the shape functions of finite element methods are polynomials, at least on the convex of reference. But, the possibility is given to have other types of elements. It is possible to define other kind of base functions such as piecewise polynomials, interpolant wavelets ...\\
To be used by the finite element description, a shape function type must be able to be evaluated on a point (\cpp{a = F.eval(pt)}, where \cpp{pt} is a \cpp{base\_node}) and must have a method to compute the derivtive with respect to the ith variable (\cpp{F.derivative(i)}).

For the moment, only polynomials and piecewise polynomials are defined in the files \cpp{bgeot\_poly.h} and \cpp{bgeot\_poly\_composite.h}


\subsection{Geometric transformations}

\begin{figure}[htb]
  \begin{center}
    \icgraphic{10cm}{getfemelemtrans}{usual elements}
  \end{center}
  \caption{ \it Geometric transformation }
  \label{fig:transgeo}
\end{figure}

A geometric transformation is a polynomial application\\
\equat{\tau : T' \subset \Reel^P \longrightarrow T \subset\Reel^N,}
which maps the reference element $T'$ to the real element $T$.
The geometric nodes are denoted
\equat{g^i, \ \ i = 0 .. n_g - 1.}
The geometric transformation is described thanks to a $n_g$ components polynomial vector (In fact, as an extention, non polynomial geometric transformation can also be supported by Getfem++, but this is very rarely used).
\equat{{\cal N}(x'),}
such that
\equat{\ds \tau(x') = \sum_{i = 0}^{n_g - 1} {\cal N}_i(x') g^i.}
Denoting
\equat{G = (g^0; g^1; ...; g^{n_g - 1}),}
the $N \times n_g$ matrix containing of all the geometric nodes, one has
\begin{center} $ \texonly{\fbox}{$\hspace{1em}\tau(x') = G {\cal N}(x').\hspace{1em}$} $ \end{center}
The derivative of $\tau$ is then
\begin{center} $ \texonly{\fbox}{$\hspace{1em} K(x') := \nabla \tau(x') = G \nabla {\cal N}(x'),\hspace{1em}$} $ \end{center}
where $K(x') = \nabla \tau(x')$ is a $N \times P$ matrix and $\nabla {\cal N}(x')$ a $n_g \times P$ matrix.
The (transposed) pseudo-inverse of $\nabla\tau(x')$ is a $N\times P$ matrix denoted $B(x')$:
\begin{center} \texonly{$\fbox}{$\hspace{1em} B(x') := K(x')(K(x')^T K(x'))^{-1},\hspace{1em}$} \texonly{$} \end{center}
Of course, when $P=N$, one has $B(x')=K(x')^{-T}$.

Pointers on a descriptor of a geometric transformation can be obtained by the following function defined in the file \cpp{bgeot\_geometric\_trans.h}:\\[0.5cm]
\cpp{bgeot::pgeometric\_trans pgt = bgeot::geometric\_trans\_descriptor("name of trans"); }\\[0.5cm]
where \cpp{"name of trans"} can be chosen among the following list.
\begin{center} \begin{ctableau}{|m{0.3\linewidth}|m{0.65\linewidth}|}{ll} \hline
\cpp{"GT\_PK(n,k)"} & Description of the simplex transformation of dimension \cpp{n} and degree \cpp{k} (Most of the time, the degree 1 is used).\\ \hline
\cpp{"GT\_QK(n,k)"} & Description of the parallelepiped transformation of dimension \cpp{n} and degree \cpp{k}.\\ \hline
\cpp{"GT\_PRISM(n,k)"} & Description of the prism transformation of dimension \cpp{n} and degree \cpp{k}. \\ \hline
\cpp{"GT\_PRODUCT(a,b)"} & Description of the direct product of the two transformations \cpp{a} and \cpp{b}.\\ \hline
\cpp{"GT\_LINEAR\_PRODUCT(a,b)"} & Description of the direct product of the two transformations \cpp{a} and \cpp{b} keeping a linear transformation (this is a restriction of he previous function). This allows, for instance, to use exact integrations on regular meshes with parallelograms. \texonly{\\ \hline}
\end{ctableau} \end{center}

\subsection{Finite element methods description}

A finite element method is defined on a reference element $T' \subset \Reel^P$ by a set of $n_d$ nodes $a^i$ and corresponding base functions 
\equat{\varphi' ^i : T' \subset \Reel^P \longrightarrow \Reel^Q,}
Denoting
\equat{\psi^i(x) = \varphi' ^i(x') = \varphi' ^i(\tau^{-1}(x)),}
a supplementary linear transformation is allowed for the real base function
\equat{\varphi^i(x) = \sum_{j = 0}^{n_d - 1} M_{ij} \psi^j(x),}
where $M$ is a $n_d \times n_d$ matrix possibly depending on the geometric transformation (i.e. on the real element). For basic elements as Lagrange elements this matrix is the identity matrix (it is simply ignored). In this case, we will say that the element is $\tau$-equivalent. This approach allows to define hermite elements (Argyris for instance) in a generic way, even with non linear transformations (i.e. mainly for curved boundaries).
We denote $[\varphi'(x')]$ the $n_d \times Q$ matrix whose ith line is $\varphi' ^i(x')$. Whis this notation, for a function is defined by 
\begin{center}$ f(x) = \sum_{i = 0}^{n_d - 1} \alpha_i \varphi^i(x), $\end{center}
one has
\begin{center} \texonly{$ \fbox}{$\hspace{1em} f(\tau(x')) = \alpha^T M [\varphi'(x')],\hspace{1em}$} \texonly{$}\end{center}
where $\alpha$ is the vector whose ith component is $\alpha_i$.

A certain number of description of classical finite element method are defined in the file \cpp{getfem\_fem.h}. See Appendix A for an exhaustive list of available finite element methods.\\

A pointer to the finite element descriptor of a method is obtained using the function\\[0.5cm]
\cpp{ getfem::pfem pfe = getfem::fem\_descriptor("name of method"); }\\[0.5cm]
We refer to the file \cpp{getfem\_fem.C} for how to define a new finite element method.



\section{Description of the different parts of the library} \label{sec:descmod}

\subsection{\gmm library}

\subsubsection{Description}

 \gmm is a linear algebra library which was originally designed to make an interface between the need in linear algebra procedures of \gf and existing free linear algebra libraries (MTL, Superlu, Blas, Lapack originally). It rapidly evolves to an independent self-consistent library with its own vector and matrix types. It is now used as a base linear algebra library by several other projects (projet KDE, \WEBB{http://websvn.kde.org/trunk/kdesupport/gmm} for instance).

However, it preserves the characteristic to be a potential interface for more specific packages. Any vector or matrix type having the minimum of compatibility can be used by generic algorithms of \gmm writing a \cpp{linalg\_traits} structure.

A \gmm standalone version is distributed since release 1.5 of \gf. It is however developed inside the \gf project even though since release 3.0 it is completely independent of any \gf file.

In addition to the linear algebra procedures, it furnishes also the following utilities to \gf.
\begin{itemize}
   \item Fix some eventual compatibility problems in \cpp{gmm\_std.h}.
   \item Error, warning and trace management in \cpp{gmm\_except.h}.
   \item Some extended math definitions in \cpp{gmm\_def.h}.
\end{itemize}

\subsubsection{State}

For the moment, \gmm cover the needs of \gf concerning the basic linear algebra procedures.

\subsubsection{Perspectives}

There is potentatialy several points to be improved in \gmm (partial introduction of expression template for some base types of matrix and vectors, reflection on the way to represent in a more coherent manner sparse sub-vectors and sub-matrices, introduction of C++ concepts ...). However, since \gmm globally cover the needs of \gf and since there exists some other project like Glas  (\WEBB{http://glas.sourceforge.net/}) to build a reference C++ library for linear algebra, a global reflection seems not necessary for the moment. This part is considered to be stabilized.

The current vocation of \gmm is to continue to collect generic algorithms and interfaces to some other packages in order to cover new needs of the whole project. The library is now frequently used as a separate package and has also the vocation to collect the contribution of any person who propose some improvements, new algorithms or new interfaces.

\subsection{Mesh module}

\subsubsection{Description}


This part of the library has the role to store and manage the meshes, i.e. a collection of elements (real elements) connected to each other by some of their faces. For that, it develops concepts of elements, elements of reference, structure of meshes, collection of nodes, geometric transformations, subpart of the boundary or subzone of the mesh.

There is no really effective meshing capabilities  available for the moment in \gf. The meshes of complex objects must be imported from existing meshers such as gmsh or GiD. Some importing functions of meshes have been written and can be easily extended for other formats.

The object which represents a mesh declared in the file \cpp{getfem\_mesh.h} and which is used as a basis for handling of the mehses in \gf manages also the possibility for the structures depending on a mesh (see MESHFEM and MESHIM modules) to react to the evolution of the mesh (addition or removal of elements ...).

\subsubsection{State}

The main C++ header files are
\begin{ctableau}{|m{0.3\linewidth}|m{0.6\linewidth}|}{ll} 
\hline \cpp{bgeot\_convex\_structure.h} & Describes the structure of an element disregarding the coordinates of its vertices.\\
\hline \cpp{bgeot\_mesh\_structure.h} & Describes the structure of a mesh disregarding the coordinates of the nodes.\\
\hline \cpp{bgeot\_node\_tab.h} & A node container allowing the fast search of a node.\\
\hline \cpp{bgeot\_convex.h} & Describes an element with its vertices.\\
\hline \cpp{bgeot\_convex\_ref.h} & Describe reference elements.\\
\hline \cpp{bgeot\_mesh.h} & Describes a mesh with the collection of node (but without the description of geometric transformations).\\
\hline \cpp{bgeot\_geometric\_trans.h} & Describes geometric transformations.\\
\hline \cpp{bgeot\_geotrans\_inv.h} & A tool to invert geometric transformations.\\
\hline \cpp{getfem\_mesh.h} & Fully describes a mesh (with the geometric transformations, subparts of the mesh, support for parallelization). Includes the Bank algorithm to refine a mesh.\\
\hline \cpp{getfem\_mesher.h} & An attempt to develop a mesher. To be use with care.
\texonly{\\ \hline}
\end{ctableau}

A prototype of mesher is in the files \cpp{getfem\_mesher.h} and \cpp{getfem\_mesher.cc} which makes it possible to mesh geometries defined by some level sets. However, the continuation of the development of this mesher is not planned for the moment because the project \gf has vocation to focus on the finite element methods themselves.

\subsubsection{Perspectives}

For the moment, the module is split into two parts which lie into two different namespaces.
Of course, It would be more coherent to gather the module in only one namespace (\cpp{getfem}).

(Note: The file \cpp{bgeot\_mesh.h} could be renamed \cpp{getfem\_basic\_mesh.h}).

A possible work to do on this part would be to examine the manner of storing the meshes and possibly to make a bibliographical study on the manner of storing a mesh (for instance see \cite{remacle2002}). It would be necessary to supplement documentation and to examine also the management of the events and the way in which the structures which depend on the mesh react to these events.

\subsection{FEM module}

\subsubsection{Description}

The FEM module is the part of \gf which describes the finite elements at the element level and the degrees of freedom. Finite element methods can be of different types. They could be scalar or vectorial, polynomial, piecewise polynomial or non-polynomial, equivalent via the geometric transformation or not. Moreover, the description of the degrees of freedom have to be such that it is possible to gather the compatible degrees of freedom between two neighbor elements in a generic way (for instance connecting a Lagrange 2D element to another Lagrange 1D element).

\subsubsection{State}

The main files of the module are
\begin{ctableau}{|m{0.3\linewidth}|m{0.6\linewidth}|}{ll} 
\hline \cpp{getfem\_fem.h} & Abstract definition of a finite element and a degree of freedom. Interface for the exported functions of \cpp{getfem\_fem.cc} and \cpp{getfem\_fem\_composite.cc}. \\
\hline \cpp{getfem\_fem.cc} & Definition of the polynomial finite elements and interface to get the descriptor on these elements (function \cpp{pfem fem\_descriptor(std::string name)}).\\
\hline \cpp{getfem\_fem\_composite.cc} & Definition of the piecewise polynomial finite elements.
\texonly{\\ \hline}
\end{ctableau}

The two files \cpp{getfem\_fem.cc} and \cpp{getfem\_fem\_composite.cc} mainly contains all the finite element description for basic elements. A exhaustive list of the defined finite elements is given in Appendix A.

Some other files define some specific finite element such as
\cpp{getfem\_fem\_level\_set.h} which is a complex construction which
allows to ``cut'' a existing element by one or several level sets (see
the LEVELSET module).

The manner to describe the degrees of freedom globally satisfies the
needing (connecting dof from an element to another in a generic way)
but is a little bit obscure and too much complicated.

Conversely, the way to represent non-equivalent elements with the
supplementary matrix \cpp{M} has proven its efficiency on several
elements (Hermites elements, Argyris ...).

\subsubsection{Perspectives}

the principal dissatisfaction of this module is that description of
the degrees of freedom is not completely satisfactory. It is the
principal reason why one documentation on how to build an element from
A to Z was not made for the moment because description of the degrees
of freedom was conceived to be temporary. An effort of design is thus
to be provided to completely stabilize this module mainly thus with
regard to the description of degrees of freedom but also perhaps the
description of finite elements which could be partially externalized in
a similar way to the cubature methods , at least for the simplest
finite elements (equivalent and polynomial finite elements).


\subsection{CUBATURE module}

\subsubsection{Description}

The CUBATURE module gives access to the numerical integration methods
on reference elements. In fact it does not only contain some cubature
formulas because it also give access to some exact integration
methods. However, the exact integration methods are only usable for
polynomial element and affine geometric transformations. This explain
why exact integration methods are not widely used. The description of
cubature formulas is done either directly in the file
\cpp{getfem\_integration.h} or via a description file in the directory
\cpp{cubature} of \gf. The addition of new cubature formulas in then
very simple, it suffices to reference the element on which it is
defined and the list of Gauss points in a file and add it to this
directory. Additionally, In order to integrate terms defined on a
boundary of a domain, the description should also contains the
reference to a method of same order on each face of the element.

\subsubsection{State}

This module meets the present needs for the project and is considered
as stabilized.  The list of available cubature formulas is given in
Appendix B.


\subsubsection{Perspectives}

No change needed for the moment. An effort could be done on the
documentation to describe completely how to add a new cubature formula
(format off descritption files).


\subsection{MESHFEM module}

to be done

\subsubsection{Description}
\subsubsection{State}
\subsubsection{Perspectives}


\subsection{LEVELSET module}

to be done

\subsubsection{Description}
\subsubsection{State}
\subsubsection{Perspectives}


\subsection{MESHIM module}

to be done

\subsubsection{Description}
\subsubsection{State}
\subsubsection{Perspectives}


\subsection{INTEGELEM module}

to be done

\subsubsection{Description}
\subsubsection{State}
\subsubsection{Perspectives}


\subsection{ASSEMBLE module}

to be done

\subsubsection{Description}
\subsubsection{State}
\subsubsection{Perspectives}


\subsection{BRICK module}

to be done

\subsubsection{Description}
\subsubsection{State}
\subsubsection{Perspectives}


\subsection{Matlab and Python interfaces}

A simplified interface of getfem++ is provided, so that it is possible to use getfem in other languages.

\subsubsection{Description}

All sources are located in the \texttt{interface/src} directory. The interface is composed of one large library \texttt{getfemint} (which stands for getfem interaction), which is acts as a layer above the getfem++ library, and is used by both the python and matlab interfaces.

This interface is not something that is generated automatically from c++ sources (as that could be the case with tools such as swig). It is something that has been designed as a simplified and consistent interface to getfem. Porting it to a new language should be quite easy (assuming the language provides some structures for dense arrays manipulations).

\subsubsection{State}

Here is a list of the various files, with a short description:
\begin{itemize}
\item \cpp{getfem_interface.cc}. This is the bridge between the script language and the getfem interface. The function getfem_interface_main is exported as an \cpp{extern "C"} function, so this is a sort of c++ barrier between the script language and the getfem interface (exporting only a C interface avoids many compilation problems).
\item \cpp{matlab/gfm_mex.c}. The matlab interface. The only thing it knows about getfem is in \cpp{getfem_interface.hh}.
\item \cpp{python/getfem_python.c}. The python interface. The only thing it knows about getfem is in \cpp{getfem_interface.hh}.

\item \cpp{gfi_array.h, gfi_array.c}. Both gfm_mex.c and getfem_python.c need a simple convention on how to send and receive arrays, and object handles, from \cpp{getfem_interface_main()}. This file provide such functionnality.

\item \cpp{getfemint_object.h}. Not all getfem objects are exported, only a selected subset, mostly mesh, mesh_im, mesh_fem, slice, bricks, etc. They are all wrapped in a common interface, which is \cpp{getfemint::getfem_object}. 

\item \cpp{getfemint_mesh.h, getfemint_mesh_fem.h, ...}. All the wrapped getfem++ objects. Some of them are quite complicated (getfemint_gsparse which export some kind of mutable sparse matrix that can switch between different storage types, and real of complex elements).

\item \cpp{gf_workspace.cc, gf_delete.cc}. Memory management for getfem objects. There is a layer in getfemint::getfem_object which handles the dependency between for example a \cpp{getfemint_mesh} and a \cpp{getfemint_mesh_fem}. It makes sure that no object will be destroyed while there is still another getfem_object using it. The goal is to make sure that under no circumstances the user is able to crash getfem (and the host program, matlab or python) by passing incorrect argument to the getfem interface. 

It also provides a kind of workspace stack, which was designed to simplify handling and cleaning of many getfem objects in matlab (since matlab does not have 'object destructors').

\item \cpp{getfemint.h, getfemint.cc}. Define the \cpp{mexarg_in}, \cpp{mexarg_out} classes, which are used to parse the list of input and output arguments to the getfem interface functions. The name is not adequate anymore since any reference to ``mex'' has been moved into \cpp{gfm_mex.c}.

\item \cpp{gf_mesh.cc, gf_mesh_get.cc, gf_mesh_set.cc, gf_fem.cc, ...}. All the functions exported be the getfem interfaces, sorted by object type (\cpp{gf_mesh*}, \cpp{gf_mesh_fem*}, \cpp{gf_fem*}), and then organized as one for the object construction (\cpp{gf_mesh}), one for the object modification (\cpp{gf_mesh_set}), and one for the object inquiry (\cpp{gf_mesh_get}). Each of these files contain one main function, that receives a \cpp{mexargs_in} and \cpp{mexargs_out} stack of arguments. It parses then, and usually interprets the first argument as the name of a subfunction (\cpp{gf_mesh_get('nbpts')} in matlab,  or \cpp{Mesh.nbpts()} in python).

\item \cpp{matlab/gfm_rpx_mexint.c}. An alternative to \cpp{gfm_mex.c} which is used when the ``\cpp{--enable-matlab-rpc}'' is passed to the \cpp{./configure} script. The main use for that is debugging the interface, since in that case, the matlab interface communicates via sockets with a ``getfem_server'' program, so it is possible to debug that server program, and identify memory leaks or anything else without having to mess with matlab (it is pain to debug).

\item \cpp{python/getfem.base.py}. The python interface is available as a '\cpp{getfem.py}' file which is built during compilation. Its source file is \cpp{getfem.base.py}, it contains just the list of classes, and for each class the names of the member functions.

\end{itemize}

\emph{Adding a new function to the getfem interface}: if one want to add a new function \cpp{gf_mesh_get(m, ``foobar'', ...)}, then the main file to modify is \cpp{gf_mesh_get.cc}. Remember to check every argument passed to the function in order to make sure that the user cannot crash matlab or python when using that function. 
Do not forget to add documentation for that function: in \cpp{gf_mesh_get.cc}, this is the documentation that appears in the matlab help files (that is when on type '\cpp{help gf_mesh_get}' at the matlab prompt), and in the getfem_python autogenerated documentation. In order to have ``foobar'' as a member function of the python Mesh class, it is necessary to add it in the \cpp{getfem.base.py} file. It is also necessary to add documentation in the \cpp{interface/doc/getfemmatlab.tex}, which was at the beginning the only documentation available. It is still very matlab oriented, and a little bit redundant with the documentation embedded in \cpp{gf_mesh_get.cc}.

\subsubsection{Perspectives}

\section{Global perspectives of structuration, consolidation and growth}

intro to the main modifications to be done ...

Modifications to be done are of three kind.

\begin{itemize}
  \item Background consolidation of the existing modules (with a reflection on the optimal representation of meshes, degrees of freedom, finite element methods ...).
  \item Developpement of innovating methods.
  \item Reflection on the optimal way to represent complex p.d.e. models with the maximum of flexibility and reusability. The brick system is a first step in this direction.
\end{itemize}

\subsection{Namespace changes}

After the elimination of the small namespaces \cpp{linkmsg} and \cpp{ftool} in release 3.0, it remains now four namespaces in the \gf project.
\begin{itemize}
 \item gmm (Generic Matrix Methods) : for the linear algebra procedures.
 \item dal (Dynamic Array Library) : some basic algorithms including the definition of some containers (\cpp{dal::dynamic_array, dal::dynamic_tas, dal::tree_sorted_array, dal::bit_vector}).
 \item bgeot (Basic GEOmetric Tool) : some basic algorithms including the definition of geometric objects (convex structure, convex, convex of reference, basic mesh).
 \item getfem : the main namespace of \gf.
\end{itemize}

It is clear that the separation into these remaining four namespaces is mainly historical. The separate gmm namespace for \gmm is clearly justified. The contour of nemaspaces \cpp{dal} and \cpp{bgeot} is more vague. Historically, those two namespaces had their own justifications.

In the very begining of \gf (the first files was written in 1995) the S.T.L. was not available and the containers defined in the \cpp{dal} namespace was used everywhere. Now, in \gf, the S.T.L. containers are mainly used. The remaining uses of \cpp{dal} containers are eather historical or due to the specificities of these containers. It is however clear that this is not the aim of the \gf project to developp new container concept. So, the use of the \cpp{dal} containers has to be as much as possible reduces.

Now, concerning \cpp{bgeot}, it was containing some other geometrical object at the begining and was originally designed to be a self-consistent library of geometric concepts. It slowly derived to be like it is now, a collection of algorithms and object definition more or less related to geometry (rtree, kdtree, ftool, polynomials ...).

The conclusion of this is that \cpp{dal} and \cpp{bgeot} namespaces can be advantageously merged to the \cpp{getfem} namespace, reducing to the minimum the use of the \cpp{dal} containers. This should be done preserving the backward compatibility. An intermediary study would be to see if the \cpp{dal} cannot be directly derived from S.T.L. containers preserving the used specificities.


\subsection{Basic types used}

Basic type of integer, real ... used. to be done.

\newpage

\section{Appendix A. Finite element method list}

Let us recall that all finite element methods defined in \gf are declared in the file \cpp{getfem\_fem.h} and that a descriptor on a finite element method is obtained thanks to the function

\cpp{getfem::pfem pf = getfem::fem\_descriptor("name of method");}

where \cpp{"name of method"} is a string to be choosen among the existing methods.

\subsection{Dof graphical codification}

\begin{figure}[H] \label{fig:symbols}
  \begin{center}
    \icgraphic{15cm}{getfemlistsymbols}{Dof graphical codification}
  \end{center}
  \caption{ \it Symbols representing degree of freedom types}
\end{figure}

\subsection{Classical $P_K$ Lagrange elements on simplices}

It is possible to define a classical $P_K$ Lagrange element of arbitrary dimension and arbitrary degree. Each degree of freedom of such an element corresponds to the value of the function on a corresponding node. The grid of node is the so-called Lagrange grid. Figures \ref{fig:segmentpk}, \ref{fig:trianglepk} and \ref{fig:tetrahedronpk} show examples in dimension 1, 2 and 3.
\begin{figure}[H] 
  \begin{center}
    \icgraphic{14cm}{getfemlistsegmentPk}{Lagrange fem on a segment}
    \caption{ \it Examples of classical $P_K$ Lagrange elements on a segment.} \label{fig:segmentpk}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \begin{tabular}{m{7cm}m{7cm}}
      \icgraphic{5cm}{getfemlisttriangleP1}{Lagrange triangle P1} &
      \icgraphic{5cm}{getfemlisttriangleP2}{Lagrange triangle P2}  \\
      $P_1$ element, 3 d.o.f., $C^0$ & $P_2$ element, 6 d.o.f., $C^0$ \\ \\
      \icgraphic{5cm}{getfemlisttriangleP3}{Lagrange triangle P3} &
      \icgraphic{5cm}{getfemlisttriangleP6}{Lagrange triangle P6}  \\
      $P_3$ element, 10 d.o.f., $C^0$ & $P_6$ element, 28 d.o.f., $C^0$
    \end{tabular}
  \end{center}
  \caption{ \it Examples of classical $P_K$ Lagrange elements on a triangle.} \label{fig:trianglepk}
\end{figure}

The number of degree of freedom for a classical $P_K$ Lagrange element of dimension $P$ and degree $K$ is $\Frac{(P+K)!}{P!K!}$. For instance, in dimension 2 ($P = 2$), this value is $\Frac{(P+1) (P+2)}{2}$ and in dimension 3 ($P = 3$), it is $\Frac{(P+1) (P+2) (P+3)}{6}$.

\begin{figure}[H]
  \begin{center}
    \begin{tabular}{m{7cm}m{7cm}}
      \icgraphic{5cm}{getfemlisttetrahedronP1}{Lagrange tetrahedron P1} &
      \icgraphic{5cm}{getfemlisttetrahedronP2}{Lagrange tetrahedron P2} \\
      $P_1$ element, 4 d.o.f., $C^0$, & $P_2$ element, 10 d.o.f., $C^0$ \\
      \icgraphic{5cm}{getfemlisttetrahedronP4}{Lagrange tetrahedron P4} &\\
      $P_4$ element, 35 d.o.f., $C^0$ &
    \end{tabular}
  \end{center}
  \caption{ \it Examples of classical $P_K$ Lagrange elements on a tetrahedron.} \label{fig:tetrahedronpk}
\end{figure}

The particular way used in \gf to numerate the nodes are also shown in figures \ref{fig:segmentpk}, \ref{fig:trianglepk} and \ref{fig:tetrahedronpk}. Using another numeration, let
\equat{ i_0, i_1, ... i_P, }
be somme indices such that
\equat{0 \leq i_0, i_1, ... i_P \leq K, \ \mbox{ and } \ \sum_{n = 0}^{P} i_n = K.}
Then, the coordinate of a node can be computed as
\equat{ a_{i_0, i_1, ... i_P} = \sum_{n = 0}^{P} \Frac{i_n}{K}S_n, \ \ \mbox{ for } K \neq 0,}
where $S_0, S_1, ... S_N$ are the vertices of the simplex (for $K = 0$ the particular choice $a_{0, 0, ... 0} = \ds \sum_{n = 0}^{P} \Frac{1}{P+1}S_n$ has been chosen).
Then each base function, corresponding of each node $a_{i_0, i_1, ... i_P}$ is defined by
\equat{\phi_{i_0, i_1, ... i_P} = \prod_{n = 0}^{P} \prod_{j=0}^{i_n-1} \left(\Frac{K \lambda_n - j}{j+1}\right).}
where $\lambda_n$ are the barycentric coordinates, i.e. the polynomials of degree 1 whose value is $1$ on the vertex $S_n$ and whose value is $0$ on other vertices. On the reference element, one has
\equat{ \lambda_n = x_n, \ \ 0 \leq n < P,}
\equat{ \lambda_P = 1 - x_0 - x_1 - ... - x_{P-1}.}

When between two elements of the same degrees (even with different dimensions), the d.o.f. of a common face are linked, the element is of class $C^0$. This means that the global polynomial is continuous. If you try to link elements of different degrees, you will get some trouble with the unlinked d.o.f. This is not automatically supported by \gf, so you will have to support it (add constraints on these d.o.f.).\\

For some applications (computation of a gradient for instance) one may not want the d.o.f. of a common face to be linked. This is why there are two versions of the classical $P_K$ Lagrange element.\\[1cm]

\femtab{Classical $P_K$ Lagrange element}{"FEM\_PK(P, K)"}{\small $K$, \mbox{$0 \leq K \leq 255$}}{\small $P$, \mbox{$ 1 \leq P \leq 255$}}{$\Frac{(K+P)!}{K! P!}$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

\femtab{Discontinuous $P_K$ Lagrange element}{"FEM\_PK\_DISCONTINUOUS(P, K)"}
{\small $K$, \mbox{$0 \leq K \leq 255$}}{\small $P$, \mbox{$ 1 \leq P \leq 255$}}{$\Frac{(K+P)!}{K! P!}$}{discon\-tinuous}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

Even thought Lagrange elements are defined for arbitrary degrees, to choose a hight degree can be problematic for a large number of applications due to the ``noisy'' caracteristic of the lagrange basis. Those element are recommended for the basic interpolation but for p.d.e. applications elements with hierarchical basis are preferable (see the corresponding section).

\subsection{Classical Lagrange elements on other geometries}

Classical Lagrange elements on parallelepipeds or prisms are obtained as tensor product of Lagrange elements on simplices. When two element are defined, one on a dimension $P^1$ and the other in dimension $P^2$, one obtains the base functions of the tensorial product (on the reference element) as
\equat{\phi'_{ij}(x,y) = \phi'^1_i(x) \phi'^2_j(y), ~ x \in \Reel^{P^1}, y \in  \Reel^{P^2},}
where $\phi'^1_i$ and $\phi'^2_i$ are respectively the base functions of the first and second element.

\begin{figure}[H]
  \begin{center} \begin{tabular}{m{7cm}m{7cm}}
      \icgraphic{5cm}{getfemlistquadQ1}{2D Q1 element} &
      \icgraphic{5cm}{getfemlistquadQ3}{2D Q3 element} \\
    $Q_1$ element, 4 d.o.f., $C^0$ & $Q_3$ element, 16 d.o.f., $C^0$ \\
  \end{tabular} \end{center}
  \caption{ \it Examples of classical $Q_K$ Lagrange elements in dimension 2} \label{fig:prodpkdeux}
\end{figure}

The $Q_K$ element on a parallelepiped of dimension $P$ is obtained as the tensorial product of $P$ classical $P_K$ element on the segment. Examples in dimension $2$ are shown in figure \ref{fig:prodpkdeux} and in dimension $3$ in figure \ref{fig:prodpktrois}. \\

A prism in dimension $P > 1$ is the direct product of a simplex of dimension $P-1$ with a segment. The $P_K \otimes P_K$ element on this prism is the tensorial product of the classical $P_K$ element on a simplex of dimension $P-1$ with the classical $P_K$ element on a segment. For $P=2$ this coincide with a parallelepiped. Examples in dimension $3$ are shown in figure \ref{fig:prodpktrois}. This is also possible not to have the same degree on each dimension. An example is shown on figure \ref{fig:prism_P2_p1}. 

\begin{figure}[H]
  \begin{center} \begin{tabular}{m{7cm}m{7cm}}
      \icgraphic{5cm}{getfemlistcubeQ1}{3D Q1 element} &
      \icgraphic{5cm}{getfemlistcubeQ3}{3D Q3 element} \\
      $Q_1$ element, 8 d.o.f., $C^0$ & $Q_3$ element, 64 d.o.f., $C^0$ \\
      \icgraphic{5cm}{getfemlistprismP1}{3D prism P1 element} &
      \icgraphic{5cm}{getfemlistprismP3}{3D prism P3 element} \\
    $P_1 \otimes P_1$ element, 6 d.o.f., $C^0$ & $P_3 \otimes P_3$ element, 40 d.o.f., $C^0$ \\
  \end{tabular} \end{center}
  \caption{ \it Examples of classical Lagrange elements in dimension 3} \label{fig:prodpktrois}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \icgraphic{3.5cm}{getfemlistprismP2P1}{3D prism P2xP1 element}
  \end{center}
  \caption{ \it $P_2 \otimes P_1$ Lagrange element on a prism, 12 d.o.f., $C^0$} 
  \label{fig:prism_P2_p1}
\end{figure}


\femtab{$Q_K$ Lagrange element on parallelepipeds}{"FEM\_QK(P, K)"}
{\small $KP$, \mbox{$0 \leq K \leq 255$}}{\small $P$, \mbox{$ 2 \leq P \leq 255$}}{$(K+1)^P$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

\femtab{$P_K \otimes P_K$ Lagrange element on prisms}{"FEM\_PK\_PRISM(P, K)"}
{\small $2K$, \mbox{$0 \leq K \leq 255$}}{\small $P$, \mbox{$ 2 \leq P \leq 255$}}{\mbox{$(K+1)$} \mbox{$\times \Frac{(K+P-1)!}{K! (P-1)!}$}}{$C^0$}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

\femtab{$P_{K_1} \otimes P_{K_2}$ Lagrange element on prisms}{"FEM\_PRODUCT(FEM\_PK(P-1, K$_1$), FEM\_PK(1, K$_2$))"}{\small \mbox{$K_1+K_2$}, \tiny \mbox{$0 \leq K_1,K_2 \leq 255$}}{\small $P$, \mbox{$ 2 \leq P \leq 255$}}{\mbox{$(K_2+1)$} \mbox{$\times \Frac{(K_1+P-1)!}{K_1! (P-1)!}$}}{$C^0$}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlistquad8}{2D Quad8 element} \\
    Incomplete $Q_2$ element, 8 d.o.f., $C^0$  \\
  \end{center}
\end{figure}

\femtab{Incomplete $Q_2$ Lagrange element on quadrilateral (Quad 8 serendipity element)}{"FEM\_INCOMPLETE\_Q2"}
{$3$}{2}{8}{$C^0$}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

 \subsection{Elements with hierarchical basis}

The idea behind hierarchical basis is the description of the solution at different level : a rought level, a more refined level ... In the same discretisation some degrees of freedom represent the rought description, some other the more rafined and so on. This correspond to imbricated spaces of discretisation. The hierarchical basis contains a basis of each of these spaces (this is not the case in classical Lagrange elements when the mesh is refined).\\[0.5cm]
Among the advantages, the condition number of  rigidity matrices can be greatly improved, it allows local raffinement and a resolution with a multigrid approach.

\subsubsection{Hiercarchical elements with respect to the degree}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlistsegmenthier}{$P_K$ Hierarchical element on a segment}
  \end{center}
  \caption{ \it $P_K$ Hierarchical element on a segment, $C^0$} 
  \label{fig:seg_hier}
\end{figure}

\femtab{$P_{K}$ Classical Lagrange element on simplices but with a hierarchical basis with respect to the degree}{"FEM\_PK\_HIERARCHICAL(P,K)"}
{\small \mbox{$K$}, \small \mbox{$0 \leq K\leq 255$}}{\small $P$, \mbox{$ 1 \leq P \leq 255$}}{\mbox{$\Frac{(K+P)!}{K! P!}$}}{$C^0$}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

\femtab{$Q_{K}$ Classical Lagrange element on parallelepipeds but with a hierarchical basis with respect to the degree}{"FEM\_QK\_HIERARCHICAL(P,K)"}
{\small \mbox{$K$}, \small \mbox{$0 \leq K\leq 255$}}{\small $P$, \mbox{$ 2 \leq P \leq 255$}}{\mbox{$(K+1)^P$}}{$C^0$}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

\femtab{$P_{K}$ Classical Lagrange element on prisms but with a hierarchical basis with respect to the degree}{"FEM\_PK\_PRISM\_HIERARCHICAL(P,K)"}
{\small \mbox{$K$}, \small \mbox{$0 \leq K\leq 255$}}{\small $P$, \mbox{$ 2 \leq P \leq 255$}}{\mbox{$(K+1)$} \mbox{$\times \Frac{(K+P-1)!}{K! (P-1)!}$}}{$C^0$}{No \mbox{($Q = 1$)}}{Yes \mbox{($M = Id$)}}{Yes}

some particular choices : $P_4$ will be build with the basis of the $P_1$, the additional basis of the $P_2$ then the additionnal basis of the $P_4$.

$P_6$ will be build  with the basis of the $P_1$, the additional basis of the $P_2$ then the additionnal basis of the $P_6$ (not with the basis of the $P_1$, 
the additional basis of the $P_3$ then the additionnal basis of the $P_6$, this is possible to build the latter with \cpp{"FEM\_GEN\_HIERARCHICAL(a,b)})

\subsubsection{Composite elements}

The principal interest of the composite elements is to build hierarchical elements. But this tool can also be used to build piecewise polynomial elements.

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlisttriangleP1comp}{a composite element}
  \end{center}
  \caption{ \it composite element {\tt "FEM\_STRUCTURED\_COMPOSITE(FEM\_PK(2,1), 3)"}} 
  \label{fig:triangle_comp}
\end{figure}

\femtab{Composition of a finite element method on a element with {\tt S} subdivisions}{"FEM\_STRUCTURED\_COMPOSITE(FEM1, S)"}
{degree of FEM1}{dimension of FEM1}{variable}{variable}{No \mbox{($Q = 1$)}}{If {\tt FEM1} is}{piecewise}

It is important to use a corresponding composite integration method.

\subsubsection{Hierarchical composite elements}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlisttriangleP1comphier}{a hierarchical composite element}
  \end{center}
  \caption{ \it hierarchical composite element {\tt "FEM\_PK\_HIERARCHICAL\_COMPOSITE(2,1,3)"}} 
  \label{fig:triangle_comp}
\end{figure}

\femtab{Hierarchical composition of a $P_K$ finite element method on a simplex with {\tt S} subdivisions}{"FEM\_PK\_HIERARCHICAL\_COMPOSITE(P,K,S)"}
{K}{P}{\mbox{$\Frac{(SK+P)!}{(SK)! P!}$}}{variable}{No \mbox{($Q = 1$)}}{If {\tt FEM1} is}{piecewise}

\femtab{hierarchical composition of a hierarchical $P_K$ finite element method on a simplex with {\tt S} subdivisions}{"FEM\_PK\_FULL\_HIERARCHICAL\_COMPOSITE(P,K,S)"}
{K}{P}{\mbox{$\Frac{(SK+P)!}{(SK)! P!}$}}{variable}{No \mbox{($Q = 1$)}}{If {\tt FEM1} is}{piecewise}

Other constructions are possible thanks to {\tt "FEM\_GEN\_HIERARCHICAL(FEM1, FEM2)"} and \\ {\tt "FEM\_STRUCTURED\_COMPOSITE(FEM1, S)"}

It is important to use a corresponding composite integration method.


\subsection{Classical vectorial elements}

\subsubsection{Raviart-Thomas of lowest order elements}

\begin{figure}[H]
  \begin{center}
    \icgraphic{10cm}{getfemlistRT0}{RT0 elements}
  \end{center}
  \caption{ \it RT0 elements in dimension two and three. (P+1 dof, H(div))} 
  \label{fig:triangle_comp}
\end{figure}

\femtab{Raviart-Thomas of lowest order element on simplices}{"FEM\_RT0(P)"}
{$1$}{$P$}{$P+1$}{$H(div)$}{Yes \mbox{($Q = P$)}}{No}{Yes}

\femtab{Raviart-Thomas of lowest order element on parallelepipeds (quadrilaterals, hexahedrals)}{"FEM\_RT0Q(P)"}
{$1$}{$P$}{$2P$}{$H(div)$}{Yes \mbox{($Q = P$)}}{No}{Yes}

\subsubsection{Nedelec (or Whitney) edge elements}

\begin{figure}[H]
  \begin{center}
    \icgraphic{10cm}{getfemlistnedelec}{Nedelec edge elements}
  \end{center}
  \caption{ \it Nedelec edge elements in dimension two and three. (P(P+1)/2 dof, H(rot))} 
  \label{fig:triangle_comp}
\end{figure}

\femtab{Nedelec (or Whitney) edge element}{"FEM\_NEDELEC(P)"}
{$1$}{$P$}{$P(P+1)/2$}{$H(rot)$}{Yes \mbox{($Q = P$)}}{No}{Yes}

\subsection{Specific elements in dimension 1}

\subsubsection{GaussLobatto element}

The 1D GaussLobatto $P_K$ element is similar to the classical $P_K$ fem on the segment, but
the nodes are given by the Gauss-Lobatto-Legendre quadrature rule of
order $2K-1$. This FEM is known to lead to better conditioned linear
systems, and can be used with the correspounding quadrature to perform
mass-lumping (on segments or parallelepipeds).

The polynomials coefficients have been pre-computed with Maple (they require the inversion of an ill-conditionned system), hence they are only available for the following values \\ of $K$: $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 24, 32$. Note that for $K=1$ and $K=2$, this is the classical $P1$ and $P2$ fem.

\femtab{GaussLobatto $P_K$ element on the segment}{"FEM\_PK\_GAUSSLOBATTO1D(K)"}{$K$}{$1$}{$K+1$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes}{Yes}

\subsubsection{Hermite element}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlistsegmenthermite}{$P_3$ Hermite element on a segment}
  \end{center}
  \caption{ \it $P_3$ Hermite element on a segment, 4 d.o.f., $C^1$} 
  \label{fig:segment_hermite}
\end{figure}

Base functions on the reference element
\equat{
  \begin{array}{ll}
    \varphi'_0 = (2x+1)(x-1)^2,&\ \ \ \varphi'_1 = x(x-1)^2, \\
    \varphi'_2 = x^2(3-2x),& \ \ \ \varphi'_3 = x^2(x - 1). 
  \end{array}
}

This element is close to be \mbox{$\tau$-equivalent} but it is not. On the real element the value of the gradient on vertices will be multiplied by the gradient of the geometric transformation. The matrix $M$ is not equal to identity but is still diagonal.

\femtab{Hermite element on the segment}{"FEM\_HERMITE(1)"}
{$3$}{$1$}{$4$}{$C^1$}{No \mbox{($Q = 1$)}}{No}{Yes}

\subsubsection{Lagrange element with an additional bubble function}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlistsegmentbubble}{$P_1$ Lagrange element on a segment with additional internal bubble function}
  \end{center}
  \caption{ \it $P_1$ Lagrange element on a segment with additional internal bubble function, 3 d.o.f., $C^0$} 
  \label{fig:segment_bubble}
\end{figure}

\femtab{Lagrange $P_1$ element with an additional internal bubble function}{"FEM\_PK\_WITH\_CUBIC\_BUBBLE(1, 1)"}{$2$}{$1$}{$3$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes}{Yes}

\subsection{Specific elements in dimension 2}
\subsubsection{Elements with additional bubble functions}

\begin{figure}[H]
  \begin{center}
    \begin{tabular}{m{7cm}m{7cm}}
      \icgraphic{5cm}{getfemlisttriangleP1bubble}{P1 triangle with additional cubic bubble} &
      \icgraphic{5cm}{getfemlisttriangleP2bubble}{P2 triangle with additional cubic bubble} \\
      $P_1$ with additional bubble function, 4 d.o.f., $C^0$ & $P_2$ with additional bubble function, 7 d.o.f., $C^0$
    \end{tabular}
  \end{center}
  \caption{ \it Lagrange element on a triangle with additional internal bubble function} 
  \label{fig:triangle_p1_bubble}
\end{figure}

\femtab{Lagrange $P_1$ or $P_2$ element with an additional internal bubble function}{"FEM\_PK\_WITH\_CUBIC\_BUBBLE(2, K)"}
{$3$}{$2$}{$4$ or $7$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes}{Yes}

\begin{figure}[H]
  \begin{center}
      \icgraphic{5cm}{getfemlisttriangleP1linbubble}{$P_1$ Lagrange element on a triangle with additional internal piecewise linear bubble function}  \\
      $P_1$ with additional bubble function, 4 d.o.f., $C^0$
  \end{center}
  \caption{ \it $P_1$ Lagrange element on a triangle with additional internal piecewise linear bubble function} 
  \label{fig:triangle_p1_bubblepie}
\end{figure}

\femtab{Lagrange $P_1$ with an additional internal piecewise linear bubble function}{"FEM\_P1\_PIECEWISE\_LINEAR\_BUBBLE"}
{$1$}{$2$}{$4$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes}{Piecewise}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlisttriangleP1bubbleface}{$P_1$ Lagrange element on a triangle with additional bubble function on face 0}
  \end{center}
  \caption{ \it $P_1$ Lagrange element on a triangle with additional bubble function on face 0, 4 d.o.f., $C^0$} 
  \label{fig:triangle_p1_bubble_face}
\end{figure}

\femtab{Lagrange $P_1$ element with an additional bubble function on face 0}{"FEM\_P1\_BUBBLE\_FACE(2)"}
{$2$}{$2$}{$4$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes}{Yes}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlisttriangleP1withP2face}{$P_1$ Lagrange element on a triangle with additional d.o.f on face 0}
  \end{center}
  \caption{ \it $P_1$ Lagrange element on a triangle with additional d.o.f on face 0, 4 d.o.f., $C^0$} 
  \label{fig:triangle_p1_p2_face}
\end{figure}

\femtab{$P_1$ Lagrange element on a triangle with additional d.o.f on face 0}{"FEM\_P1\_BUBBLE\_FACE\_LAG"}
{$2$}{$2$}{$4$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes}{Yes}

\subsubsection{Non-conforming $P_1$ element}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlisttriangleP1nonconforming}{$P_1$ non-conforming element on a triangle}
  \end{center}
  \caption{ \it $P_1$ non-conforming element on a triangle, 3 d.o.f., discontinuous} 
  \label{fig:triangle_non_conforming}
\end{figure}

\femtab{$P_1$ non-conforming element on a triangle}{"FEM\_P1\_NONCONFORMING"}
{$1$}{$2$}{$3$}{discon\-tinuous}{No \mbox{($Q = 1$)}}{Yes}{Yes}

\subsubsection{Hermite element}

\begin{figure}[H]
  \begin{center}
    \icgraphic{6cm}{getfemlisttrianglehermite}{Hermite element on a triangle}
  \end{center}
  \caption{ \it Hermite element on a triangle, $P_3$, 10 d.o.f., $C^0$ }
  \label{fig:triangle_hermite}
\end{figure}

Base functions on the reference element:
\equat{
\begin{array}{ll}
  \varphi'_0 = (1-x-y)(1+x+y-2x^2-2y^2-11xy),~ & (\varphi'_0(0,0) = 1), \\
  \varphi'_1 = x(1-x-y)(1-x-2y), & (\partial_x\varphi'_1(0,0) = 1), \\
  \varphi'_2 = y(1-x-y)(1-2x-y), & (\partial_y\varphi'_2(0,0) = 1), \\
  \varphi'_3 = -2x^3 + 7 x^2y + 7xy^2 + 3x^2 - 7xy, & (\varphi'_3(1,0) = 1), \\
  \varphi'_4 = x^3-2x^2y-2xy^2-x^2+2xy, & (\partial_x\varphi'_4(1,0) = 1), \\
  \varphi'_5 = xy(y+2x-1), & (\partial_y\varphi'_5(1,0) = 1), \\
  \varphi'_6 = 7x^2y + 7xy^2 - 2y^3+3y^2-7xy, & (\varphi'_6(0,1) = 1), \\
  \varphi'_7 = xy(x+2y-1), & (\partial_x\varphi'_7(0,1) = 1), \\
  \varphi'_8 = y^3-2x^2y-2xy^2-y^2+2xy, & (\partial_y\varphi'_8(0,1) = 1), \\
  \varphi'_9 = 27xy(1-x-y), & (\varphi'_9(1/3,1/3) = 1), \\
\end{array}
}
This element is not \mbox{$\tau$-equivalent} (The matrix $M$ is not equal to identity). On the real element linear combinaisons of $\varphi'_4$ and $\varphi'_7$ are used to match the gradient on the corresponding vertex. Idem for the two couples ($\varphi'_5$, $\varphi'_8$) and  ($\varphi'_6$, $\varphi'_9$) for the two other vertices.  

\femtab{Hermite element on a triangle}{"FEM\_HERMITE(2)"}
{$3$}{$2$}{$10$}{$C^0$}{No \mbox{($Q = 1$)}}{No}{Yes}

\subsubsection{Morley element}

\begin{figure}[H]
  \begin{center}
    \icgraphic{6cm}{getfemlistmorley}{triangle Morley element}
  \end{center}
  \caption{ \it triangle Morley element, $P_2$, 6 d.o.f., $C^0$ }
  \label{fig:triangle_morley}
\end{figure}

This element is not \mbox{$\tau$-equivalent} (The matrix $M$ is not equal to identity). In particular, it can be used for non-conforming discretization of fourth order problems, despite the fact that it is not ${\cal C}^0$.

\femtab{Morley element on a triangle}{"FEM\_MORLEY"}
{$2$}{$2$}{$6$}{  }{No \mbox{($Q = 1$)}}{No}{Yes}

\subsubsection{Argyris element}

\begin{figure}[H]
  \begin{center}
    \icgraphic{6cm}{getfemlistargyris}{Argyris element}
  \end{center}
  \caption{ \it Argyris element, $P_5$, 21 d.o.f., $C^1$}
  \label{fig:argyris}
\end{figure}

The base functions on the reference element are:
\equat{ \begin{array}{ll}
\varphi'_{0}(x,y) = 1 - 10x^3 - 10y^3 + 15x^4 - 30x^2y^2 + 15y^4 - 6x^5 + 30x^3y^2 + 30x^2y^3 - 6y^5, & (\varphi'_0(0,0) = 1), \\
\varphi'_{1}(x,y) = x - 6x^3 - 11xy^2 + 8x^4 + 10x^2y^2 + 18xy^3 - 3x^5 + x^3y^2 - 10x^2y^3 - 8xy^4, & (\partial_x\varphi'_1(0,0) = 1),\\
\varphi'_{2}(x,y) = y - 11x^2y - 6y^3 + 18x^3y + 10x^2y^2 + 8y^4 - 8x^4y - 10x^3y^2 + x^2y^3 - 3y^5, & (\partial_y\varphi'_2(0,0) = 1),\\
\varphi'_{3}(x,y) = 0.5x^2 - 1.5x^3 + 1.5x^4 - 1.5x^2y^2 - 0.5x^5 + 1.5x^3y^2 + x^2y^3, & (\partial^2_{xx}\varphi'_3(0,0) = 1),\\
\varphi'_{4}(x,y) = xy - 4x^2y - 4xy^2 + 5x^3y + 10x^2y^2 + 5xy^3 - 2x^4y - 6x^3y^2 - 6x^2y^3 - 2xy^4, & (\partial^2_{xy}\varphi'_{4}(0,0) = 1),\\
\varphi'_{5}(x,y) = 0.5y^2 - 1.5y^3 - 1.5x^2y^2 + 1.5y^4 + x^3y^2 + 1.5x^2y^3 - 0.5y^5, & (\partial^2_{yy}\varphi'_{5}(0,0) = 1),\\
\varphi'_{6}(x,y) = 10x^3 - 15x^4 + 15x^2y^2 + 6x^5 - 15x^3y^2 - 15x^2y^3, & (\varphi'_6(1,0) = 1),\\
\varphi'_{7}(x,y) = -4x^3 + 7x^4 - 3.5x^2y^2 - 3x^5 + 3.5x^3y^2 + 3.5x^2y^3, & (\partial_x\varphi'_7(1,0) = 1),\\
\varphi'_{8}(x,y) = -5x^2y + 14x^3y + 18.5x^2y^2 - 8x^4y - 18.5x^3y^2 - 13.5x^2y^3, & (\partial_y\varphi'_8(1,0) = 1),\\
\varphi'_{9}(x,y) = 0.5x^3 - x^4 + 0.25x^2y^2 + 0.5x^5 - 0.25x^3y^2 - 0.25x^2y^3, & (\partial^2_{xx}\varphi'_{9}(1,0) = 1),\\
\varphi'_{10}(x,y) = x^2y - 3x^3y - 3.5x^2y^2 + 2x^4y + 3.5x^3y^2 + 2.5x^2y^3, & (\partial^2_{xy}\varphi'_{10}(1,0) = 1),\\
\varphi'_{11}(x,y) = 1.25x^2y^2 - 0.75x^3y^2 - 1.25x^2y^3, & (\partial^2_{yy}\varphi'_{11}(1,0) = 1),\\
\varphi'_{12}(x,y) = 10y^3 + 15x^2y^2 - 15y^4 - 15x^3y^2 - 15x^2y^3 + 6y^5, & (\varphi'_{12}(0,1) = 1),\\
\varphi'_{13}(x,y) = -5xy^2 + 18.5x^2y^2 + 14xy^3 - 13.5x^3y^2 - 18.5x^2y^3 - 8xy^4, & (\partial_x\varphi'_{13}(0,1) = 1),\\
\varphi'_{14}(x,y) = -4y^3 - 3.5x^2y^2 + 7y^4 + 3.5x^3y^2 + 3.5x^2y^3 - 3y^5, & (\partial_y\varphi'_{14}(0,0) = 1),\\
\varphi'_{15}(x,y) = 1.25x^2y^2 - 1.25x^3y^2 - 0.75x^2y^3, & (\partial^2_{xx}\varphi'_{15}(0,1) = 1),\\
\varphi'_{16}(x,y) = xy^2 - 3.5x^2y^2 - 3xy^3 + 2.5x^3y^2 + 3.5x^2y^3 + 2xy^4, & (\partial^2_{xy}\varphi'_{16}(0,1) = 1),\\
\varphi'_{17}(x,y) = 0.5y^3 + 0.25x^2y^2 - y^4 - 0.25x^3y^2 - 0.25x^2y^3 + 0.5y^5, & (\partial^2_{yy}\varphi'_{17}(0,1) = 1),\\
\varphi'_{18}(x,y) = \sqrt{2}(-8x^2y^2 + 8x^3y^2 + 8x^2y^3), & \hspace{-10.5em}(\sqrt{0.5}(\partial_{x}\varphi'_{18}(0.5,0.5) + \partial_{y}\varphi'_{18}(0.5,0.5)) = 1),\\
\varphi'_{19}(x,y) = -16xy^2 + 32x^2y^2 + 32xy^3 - 16x^3y^2 - 32x^2y^3 - 16xy^4, & (-\partial_{x}\varphi'_{19}(0,0.5) = 1),\\
\varphi'_{20}(x,y) = -16x^2y + 32x^3y + 32x^2y^2 - 16x^4y - 32x^3y^2 - 16x^2y^3, & (-\partial_{y}\varphi'_{20}(0.5,0) = 1),\\
\end{array}
}

This element is not \mbox{$\tau$-equivalent} (The matrix $M$ is not equal to identity). On the real element linear combinaisons of the transformed base functions $\varphi'_i$ are used to match the gradient, the second derivatives and the normal derivatives on the faces. Note that the use of the matrix  $M$ allows to define Argyris element even with nonlinear geometric transformations (for instance to treat curved boundaries).


\femtab{Argyris element on a triangle}{"FEM\_ARGYRIS"}
{$5$}{$2$}{$21$}{$C^1$}{No \mbox{($Q = 1$)}}{No}{Yes}

\subsubsection{Hsieh-Clough-Tocher element}

\begin{figure}[H]
  \begin{center}
    \icgraphic{6cm}{getfemlistHCT}{Hsieh-Clough-Tocher (HCT) element}
  \end{center}
  \caption{ \it Hsieh-Clough-Tocher (HCT) element, $P_3$, 12 d.o.f., $C^1$}
  \label{fig:HCT_tr}
\end{figure}

This element is not \mbox{$\tau$-equivalent}. This is a composite element. Polynomial of degree 3 on each of the three sub-triangles (see figure \ref{fig:HCT_tr} and \cite{ciarlet1978}). It is strongly advised to use a \cpp{ IM\_HCT\_COMPOSITE } integration method with this finite element. The numeration of the dof is the following : 0, 3 and 6 for the lagrange dof on the first second and third vertex respectively; 1, 4, 7 for the derivative with respects to the first variable; 2, 5, 8 for the derivative with respects to the second variable and 9, 10, 11 for the normal derivatives on face 0, 1, 2 respectively.\\

\femtab{HCT element on a triangle}{"FEM\_HCT\_TRIANGLE"}
{$3$}{$2$}{$12$}{$C^1$}{No \mbox{($Q = 1$)}}{No}{piecewise}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5.5cm}{getfemlistreducedHCT}{ Reduced Hsieh-Clough-Tocher (reduced HCT) element}
  \end{center}
  \caption{ \it Reduced Hsieh-Clough-Tocher (reduced HCT) element, $P_3$, 9 d.o.f., $C^1$}
  \label{fig:reduced_HCT_tr}
\end{figure}

This element exists also in its reduced form, where the normal derivatives is assumed to be polynomial of degree one on each edge (see figure \ref{fig:reduced_HCT_tr})


\femtab{Reduced HCT element on a triangle}{"FEM\_REDUCED\_HCT\_TRIANGLE"}
{$3$}{$2$}{$9$}{$C^1$}{No \mbox{($Q = 1$)}}{No}{piecewise}

\subsubsection{A composite $C^1$ element on quadrilaterals}

\begin{figure}[H]
  \begin{center}
    \icgraphic{6cm}{getfemlistquadc1composite}{$C^1$ composite element on quadrilaterals}
  \end{center}
  \caption{ \it Composite element on quadrilaterals, piecewise $P_3$, 16 d.o.f., $C^1$}
  \label{fig:QC1_tr}
\end{figure}

This element is not \mbox{$\tau$-equivalent}. This is a composite element. Polynomial of degree 3 on each of the four sub-triangles (see figure \ref{fig:QC1_tr}). At least on the reference element it correponds to the Fraeijs de Veubeke-Sander element (see \cite{ciarlet1978}). It is strongly advised to use a \cpp{ IM\_QUADC1\_COMPOSITE } integration method with this finite element. \\

\femtab{$C^1$ composite element on a quadrilateral (FVS)}{"FEM\_QUADC1\_COMPOSITE"}
{$3$}{$2$}{$16$}{$C^1$}{No \mbox{($Q = 1$)}}{No}{piecewise}


\begin{figure}[H]
  \begin{center}
    \icgraphic{5.5cm}{getfemlistreducedquadc1composite}{Reduced $C^1$ composite element on quadrilaterals}
  \end{center}
  \caption{ \it Reduced composite element on quadrilaterals, piecewise $P_3$, 12 d.o.f., $C^1$}
  \label{fig:reduced_QC1_tr}
\end{figure}

This element exists also in its reduced form, where the normal derivatives is assumed to be polynomial of degree one on each edge (see figure \ref{fig:reduced_QC1_tr})

\femtab{Reduced $C^1$ composite element on a quadrilateral (reduced FVS)}{"FEM\_REDUCED\_QUADC1\_COMPOSITE"}
{$3$}{$2$}{$12$}{$C^1$}{No \mbox{($Q = 1$)}}{No}{piecewise}


\subsection{Specific elements in dimension 3}
\subsubsection{Elements with additional bubble functions}
\begin{figure}[H]
  \begin{center}
    \begin{tabular}{m{5cm}m{5cm}m{5cm}}
      \icgraphic{4.5cm}{getfemlisttetrahedronP1bubble}{$P_1$ with additional bubble function in 3D} &
      \icgraphic{4.5cm}{getfemlisttetrahedronP2bubble}{$P_2$ with additional bubble function in 3D} &
      \icgraphic{4.5cm}{getfemlisttetrahedronP3bubble}{$P_3$ with additional bubble function in 3D} \\
      $P_1$ with additional bubble function, 5 d.o.f., $C^0$ & $P_2$ with additional bubble function, 11 d.o.f., $C^0$ & $P_3$ with additional bubble function, 21 d.o.f., $C^0$
    \end{tabular}
  \end{center}
  \caption{ \it Lagrange element on a tetrahedron with additional internal bubble function.} 
  \label{fig:tetrahedron_p1_bubble}
\end{figure}

\femtab{$P_K$ Lagrange element with an additional internal bubble function}
{"FEM\_PK\_WITH\_CUBIC\_BUBBLE(3, K)"}
{$4$}{$3$}{$5$, $11$ or $21$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes}{Yes}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlisttetrahedronP1bubbleface}{$P_1$ Lagrange element on a tetrahedron with additional bubble function on face 0}
  \end{center}
  \caption{ \it $P_1$ Lagrange element on a tetrahedron with additional bubble function on face 0, 5 d.o.f., $C^0$} 
  \label{fig:tetrahedron_p1_bubble_face}
\end{figure}

\femtab{Lagrange $P_1$ element with an additional bubble function on face 0}
{"FEM\_P1\_BUBBLE\_FACE(3)"}
{$3$}{$3$}{$5$}{$C^0$}{No \mbox{($Q = 1$)}}{Yes}{Yes}

\subsubsection{Hermite element}

\begin{figure}[H]
  \begin{center}
    \icgraphic{6cm}{getfemlisttetrahedronhermite}{Hermite element on a tetrahedron}
  \end{center}
  \caption{ \it Hermite element on a tetrahedron, $P_3$, 20 d.o.f., $C^0$}
  \label{fig:tetrahedron_hermite}
\end{figure}

Base functions on the reference element:
\equat{
  \begin{array}{ll}
\varphi'_{0}(x,y) = 1 - 3x^2 - 13xy - 13xz - 3y^2 - 13yz - 3z^2 + 2x^3 + 13x^2y + 13x^2z & \\
 ~~~~~~~ + 13xy^2 + 33xyz + 13xz^2 + 2y^3 + 13y^2z + 13yz^2 + 2z^3, & (\varphi'_0(0,0,0) = 1),\\
\varphi'_{1}(x,y) = x - 2x^2 - 3xy - 3xz + x^3 + 3x^2y + 3x^2z + 2xy^2 + 4xyz + 2xz^2, & (\partial_x\varphi'_1(0,0,0) = 1),\\
\varphi'_{2}(x,y) = y - 3xy - 2y^2 - 3yz + 2x^2y + 3xy^2 + 4xyz + y^3 + 3y^2z + 2yz^2, & (\partial_y\varphi'_2(0,0,0) = 1),\\
\varphi'_{3}(x,y) = z - 3xz - 3yz - 2z^2 + 2x^2z + 4xyz + 3xz^2 + 2y^2z + 3yz^2 + z^3, & (\partial_z\varphi'_3(0,0,0) = 1),\\
\varphi'_{4}(x,y) = 3x^2 - 7xy - 7xz - 2x^3 + 7x^2y + 7x^2z + 7xy^2 + 7xyz + 7xz^2, & (\varphi'_4(1,0,0) = 1),\\
\varphi'_{5}(x,y) = -x^2 + 2xy + 2xz + x^3 - 2x^2y - 2x^2z - 2xy^2 - 2xyz - 2xz^2, & (\partial_x\varphi'_5(1,0,0) = 1),\\
\varphi'_{6}(x,y) = -xy + 2x^2y + xy^2, & (\partial_y\varphi'_6(1,0,0) = 1),\\
\varphi'_{7}(x,y) = -xz + 2x^2z + xz^2, & (\partial_z\varphi'_7(1,0,0) = 1),\\
\varphi'_{8}(x,y) = -7xy + 3y^2 - 7yz + 7x^2y + 7xy^2 + 7xyz - 2y^3 + 7y^2z + 7yz^2, & (\varphi'_8(0,1,0) = 1),\\
\varphi'_{9}(x,y) = -xy + x^2y + 2xy^2, & (\partial_x\varphi'_9(0,1,0) = 1),\\
\varphi'_{10}(x,y) = 2xy - y^2 + 2yz - 2x^2y - 2xy^2 - 2xyz + y^3 - 2y^2z - 2yz^2, & (\partial_y\varphi'_{10}(0,1,0) = 1),\\
\varphi'_{11}(x,y) = -yz + 2y^2z + yz^2, & (\partial_z\varphi'_{11}(0,1,0) = 1),\\
\varphi'_{12}(x,y) = -7xz - 7yz + 3z^2 + 7x^2z + 7xyz + 7xz^2 + 7y^2z + 7yz^2 - 2z^3, & (\varphi'_{12}(0,0,1) = 1),\\
\varphi'_{13}(x,y) = -xz + x^2z + 2xz^2, & (\partial_x\varphi'_{13}(0,0,1) = 1),\\
\varphi'_{14}(x,y) = -yz + y^2z + 2yz^2, & (\partial_y\varphi'_{14}(0,0,1) = 1),\\
\varphi'_{15}(x,y) = 2xz + 2yz - z^2 - 2x^2z - 2xyz - 2xz^2 - 2y^2z - 2yz^2 + z^3, & (\partial_z\varphi'_{15}(0,0,1) = 1),\\
\varphi'_{16}(x,y) = 27xyz, & (\varphi'_{16}(1/3,1/3,1/3) = 1),\\
\varphi'_{17}(x,y) = 27yz - 27xyz - 27y^2z - 27yz^2, & (\varphi'_{17}(0,1/3,1/3) = 1),\\
\varphi'_{18}(x,y) = 27xz - 27x^2z - 27xyz - 27xz^2, & (\varphi'_{18}(1/3,0,1/3) = 1),\\
\varphi'_{19}(x,y) = 27xy - 27x^2y - 27xy^2 - 27xyz, & (\varphi'_{19}(1/3,1/3,0) = 1),\\
  \end{array}
}
This element is not \mbox{$\tau$-equivalent} (The matrix $M$ is not equal to identity). On the real element linear combinaisons of $\varphi'_8$, $\varphi'_{12}$ and $\varphi'_{16}$ are used to match the gradient on the corresponding vertex. Idem on the orther vertices. 

\femtab{Hermite element on a tetrahedron}{"FEM\_HERMITE(3)"}
{$3$}{$3$}{$20$}{$C^0$}{No \mbox{($Q = 1$)}}{No}{Yes}

\newpage

\section{Appendix B. Cubature method list}

The integration methods are of two kinds. Exact integrations of polynomials and approximated integrations (cubature formulas) of any function. The exact integration can only be used if all the elements are polynomial and if the geometric transformation is linear.

A descriptor on an integration method is given by the function

\cpp{ppi = getfem::int\_method\_descriptor("name of method");}

where \cpp{\tt "name of method"} is a string to be choosen among the existing methods.

The program \cpp{integration} located in the \cpp{tests} directory lists and checks the degree of each integration method.

\subsection{Exact Integration methods}

The list of available Exact integration methods is the following


\begin{center} \begin{tabular}{|m{0.4\linewidth}|m{0.55\linewidth}|} \hline
\cpp{"IM\_NONE()"} & Dummy integration method.\\ \hline
\cpp{"IM\_EXACT\_SIMPLEX(n)"} & Description of the exact integration of polynomials on the simplex of reference of dimension {\tt n}. \\ \hline
\cpp{"IM\_PRODUCT(a, b)"} & Description of the exact integration on the convex which is the direct product of the convex in {\tt a} and in {\tt b}.\\ \hline
\cpp{"IM\_EXACT\_PARALLELEPIPED(n)"} & Description of the exact integration of polynomials on the parallelepiped of reference of dimension {\tt n}\\ \hline
\cpp{"IM\_EXACT\_PRISM(n)"} & Description of the exact integration of polynomials on the prism of reference of dimension {\tt n}\\ \hline
\end{tabular} \end{center}

Even though a description of exact integration method exists on parallelepipeds or prisms, most of the time the geometric transformations on such elements are not linear and the exact integration cannot be used.\\

Beware : In fact a lot of computation cannot be done with exact integration methods. So, it is recommended to use cubature formulas instead.

\subsection{Newton cotes Integration methods}

use \cpp{"IM\_NC(N,K)"}, \cpp{ "IM\_NC\_PARALLELEPIPED(N,K)"}
and \cpp{ "IM\_NC\_PRISM(N,K)"} to have the Newton cotes integration of order \cpp{K} on simplices, parallelepipeds and prisms respectively.


\subsection{Gauss Integration methods on dimension 1}

use \cpp{ "IM\_GAUSS1D(K)"} to have the Gauss-Legendre integration on the segment of order \cpp{ K} (with \cpp{ K}/2 + 1 points), and \cpp{ "IM\_GAUSSLOBATTO1D(K)"} to have the Gauss-Lobatto-Legendre integration on the segment of order \cpp{ K} (with \cpp{ K}/2 + 1 points). The latter integration method is only available for odd values of $K$. The Gauss-Lobatto integration method can be used in conjunction with \cpp{ "FEM\_PK\_GAUSSLOBATTO1D(K/2)"} to perform mass-lumping.

\subsection{Gauss Integration methods on dimension 2}

\begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|} \hline 
graphic & coordinates \hspace{5em} \begin{tabular}{m{3cm}m{3cm}} x & y  \end{tabular} & weights & function to call / order \\ \hline
\texonly{
\end{tabular}
\begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
  \hline& & &\\ 
  \icgraphic{2.5cm}{getfemlistintmethodtriangle1}{IM\_TRIANGLE(1)} & 
  { \small
    \begin{tabular}{m{3cm}m{3cm}}
      $1/3$ & $1/3$ 
    \end{tabular}
    }
  & 
    \begin{tabular}{c}
      1/2
    \end{tabular}
  & \cpp{ \small "IM\_TRIANGLE(1)"} \hspace{9em} 
    1 point, order 1. \\ \hline
\texonly{
\end{tabular}
\begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
  \hline& & &\\ 
  \icgraphic{2.5cm}{getfemlistintmethodtriangle2}{"IM\_TRIANGLE(2)"} & 
  { \small
    \begin{tabular}{m{3cm}m{3cm}}
      $1/6$ & $1/6$ \\ \\
      $2/3$ & $1/6$  \\ \\
      $1/6$ & $2/3$
    \end{tabular}
    }
  & 
    \begin{tabular}{c}
      1/6 \\ \\
      1/6 \\ \\
      1/6
    \end{tabular}
  & \cpp{ \small "IM\_TRIANGLE(2)"} \hspace{9em} 3 points, order 2. \\ \hline
\texonly{
\end{tabular} 
\begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
  \hline& & &\\ 
  \icgraphic{2.5cm}{getfemlistintmethodtriangle3}{"IM\_TRIANGLE(3)"} & 
  { \small
    \begin{tabular}{m{3cm}m{3cm}}
      $1/3$ & $1/3$ \\ \\
      $1/5$ & $1/5$ \\ \\
      $3/5$ & $1/5$ \\ \\
      $1/5$ & $3/5$
    \end{tabular}
    }
  & { \small
    \begin{tabular}{c}
      -27/96 \\ \\
      25/96 \\ \\
      25/96 \\ \\ 
      25/96 
    \end{tabular} }
  & \cpp{ \small "IM\_TRIANGLE(3)"} \hspace{9em} 4 points, order 3. \\ \hline
\texonly{
\end{tabular} 
\begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
  \hline& & &\\
  \icgraphic{2.5cm}{getfemlistintmethodtriangle4}{"IM\_TRIANGLE(4)"} & 
  { \small
    \begin{tabular}{m{3cm}m{3cm}}
      $a$ & $a$ \\ 
      $1-2a$ & $a$ \\ 
      $a$ & $1-2a$ \\ 
      $b$ & $b$ \\ 
      $1-2b$ & $b$  \\ 
      $b$ & $1-2b$
    \end{tabular}
    }
  & { \small
    \begin{tabular}{c}
      c \\ 
      c \\ 
      c \\ 
      d \\ 
      d \\ 
      d
    \end{tabular} }
  & \cpp{ \small "IM\_TRIANGLE(4)"} \hspace{7em} \mbox{6 points, order 4,}\hspace{7em} \mbox{a = 0.445948490915965,}\hspace{5em} \mbox{b = 0.091576213509771,}\hspace{5em} \mbox{c = 0.111690794839005,}\hspace{5em} \mbox{d = 0.054975871827661.} \\ \hline
\texonly{
\end{tabular} 
\begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
  \hline& & &\\
  \icgraphic{2.5cm}{getfemlistintmethodtriangle5}{"IM\_TRIANGLE(5)"} & 
  { \small
    \begin{tabular}{m{3cm}m{3cm}}
      $1/3$ & $1/3$ \\ 
      $a$ & $a$ \\ 
      $1-2a$ & $a$ \\ 
      $a$ & $1-2a$ \\ 
      $b$ & $b$ \\ 
      $1-2b$ & $b$  \\ 
      $b$ & $1-2b$
    \end{tabular}
    }
  & { \small
    \begin{tabular}{c}
      9/80 \\ 
      c \\ 
      c \\ 
      c \\ 
      d \\ 
      d \\ 
      d 
    \end{tabular} }
  & \cpp{ \small "IM\_TRIANGLE(5)"} \hspace{7em} \mbox{7 points, order 5,}\hspace{7em} \mbox{$a = \Frac{6+\sqrt{15}}{21}$,}\hspace{5em} \mbox{$b = 4/7 - a$,}\hspace{8em} \mbox{$c = \Frac{155+\sqrt{15}}{2400}$,}\hspace{5em} \mbox{$d = 31/240 - c$.} \\ \hline
\texonly{
\end{tabular}  
\begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
\hline& & &\\
  \icgraphic{2.5cm}{getfemlistintmethodtriangle6}{"IM\_TRIANGLE(6)"} & 
  { \small
    \begin{tabular}{m{3cm}m{3cm}}
      $a$ & $a$ \\ 
      $1-2a$ & $a$ \\ 
      $a$ & $1-2a$ \\ 
      $b$ & $b$ \\ 
      $1-2b$ & $b$ \\ 
      $b$ & $1-2b$ \\ 
      $c$ & $d$ \\ 
      $d$ & $c$ \\ 
      $1-c-d$ & $c$ \\ 
      $1-c-d$ & $d$ \\ 
      $c$ & $1-c-d$ \\ 
      $d$ & $1-c-d$
    \end{tabular}
    }
  & { \small
    \begin{tabular}{c}
      e \\
      e \\ 
      e \\ 
      f \\  
      f \\ 
      f \\ 
      g \\ 
      g \\ 
      g \\ 
      g \\ 
      g \\ 
      g
    \end{tabular} }
  & \cpp{ \small "IM\_TRIANGLE(6)"} \hspace{7em} \mbox{12 points, order 6,}\hspace{7em}
  \mbox{$a = 0.063089104491502$,}\hspace{5em}
  \mbox{$b = 0.249286745170910$,}\hspace{8em}
  \mbox{$c = 0.310352451033785$,}\hspace{5em}
  \mbox{$d = 0.053145049844816$,}\hspace{5em}
  \mbox{$e = 0.025422453185103$,}\hspace{5em}
  \mbox{$f = 0.058393137863189$,}\hspace{5em}
  \mbox{$g = 0.041425537809187$.}\hspace{5em}
  \\ \hline
\texonly{
\end{tabular}  
\begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
  \hline& & &\\
  \icgraphic{2.5cm}{getfemlistintmethodtriangle7}{"IM\_TRIANGLE(7)"} &
  { \small
    \begin{tabular}{m{3cm}m{3cm}}
      $a$ & $a$ \\ 
      $b$ & $a$ \\ 
      $a$ & $b$ \\ 
      $c$ & $e$ \\ 
      $d$ & $c$ \\ 
      $e$ & $d$ \\ 
      $d$ & $e$ \\ 
      $c$ & $d$ \\ 
      $e$ & $c$ \\ 
      $f$ & $f$ \\ 
      $g$ & $f$ \\ 
      $f$ & $g$ \\
      $1/3$ & $1/3$ 
    \end{tabular}
    }
  & { \small
    \begin{tabular}{c}
      h \\
      h \\ 
      h \\ 
      i \\  
      i \\ 
      i \\ 
      i \\ 
       i \\ 
       i \\
       j \\
       j \\
       j \\
       k
     \end{tabular} }
   & \cpp{ \small "IM\_TRIANGLE(7)"} \hspace{7em} \mbox{13 points, order 7,}\hspace{7em}
   \mbox{$a = 0.0651301029022$,}\hspace{5em}
   \mbox{$b = 0.8697397941956$,}\hspace{5em}
   \mbox{$c = 0.3128654960049$,}\hspace{5em}
   \mbox{$d = 0.6384441885698$,}\hspace{5em}
   \mbox{$e = 0.0486903154253$,}\hspace{5em}
   \mbox{$f = 0.2603459660790$,}\hspace{5em}
   \mbox{$g = 0.4793080678419$,}\hspace{5em}
   \mbox{$h = 0.0266736178044$,}\hspace{5em}
   \mbox{$i = 0.0385568804451$,}\hspace{5em}
   \mbox{$j = 0.0878076287166$,}\hspace{5em}
   \mbox{$k = -0.0747850222338$.}\hspace{5em}
   \\ \hline
\texonly{
 \end{tabular}  
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|} \hline
}
 &&&\cpp{ \small "IM\_TRIANGLE(8)"}(see \cite{EncyclopCubature}) \hspace{7em} \mbox{16 points, order 8}\hspace{7em} \\ \hline
\texonly{
 \end{tabular}
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|} \hline
}
 &&&\cpp{ \small "IM\_TRIANGLE(9)"}(see \cite{EncyclopCubature}) \hspace{7em} \mbox{19 points, order 9}\hspace{7em} \\ \hline
\texonly{ \end{tabular}
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|} \hline
}
 &&&\cpp{ \small "IM\_TRIANGLE(10)"}(see \cite{EncyclopCubature}) \hspace{7em} \mbox{25 points, order 10}\hspace{7em} \\ \hline
\texonly{ \end{tabular}
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|} \hline
}
 &&&\cpp{ \small "IM\_TRIANGLE(13)"}(see \cite{EncyclopCubature}) \hspace{7em} \mbox{37 points, order 13}\hspace{7em} \\ \hline
\texonly{ \end{tabular}
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
   \hline& & &\\
   \icgraphic{2.5cm}{getfemlistintmethodquad2}{"IM\_QUAD(2)"} &
   { \small
     \begin{tabular}{m{3cm}m{3cm}}
       $1/2+\sqrt{1/6}$ & $1/2$ \\ \\
       $1/2-\sqrt{1/24}$ & $1/2\pm\sqrt{1/8}$ 
     \end{tabular}
     }
   & 
     \begin{tabular}{c}
       1/3 \\ \\
       1/3
     \end{tabular}
   & \cpp{ \small "IM\_QUAD(2)"} \hspace{11em} 3 points, order 2. \\ \hline
\texonly{
 \end{tabular}  
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
   \hline& & &\\ 
   \icgraphic{2.5cm}{getfemlistintmethodquad3}{"IM\_QUAD(3)"} &
   { \small
     \begin{tabular}{m{3cm}m{3cm}}
       $1/2\pm\sqrt{1/6}$ & $1/2$ \\ \\
       $1/2$ & $1/2\pm\sqrt{1/6}$ 
     \end{tabular}
     }
   & 
     \begin{tabular}{c}
       1/4 \\ \\
       1/4
     \end{tabular}
   & \cpp{ \small "IM\_QUAD(3)"} \hspace{11em} 4 points, order 3. \\ \hline
\texonly{
 \end{tabular} 
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|}
}
   \hline& & &\\ 
   \icgraphic{2.5cm}{getfemlistintmethodquad5}{"IM\_QUAD(5)"} &
   { \small
     \begin{tabular}{m{3cm}m{3cm}}
       1/2 & 1/2 \\ \\
       $1/2 \pm \sqrt{7/30}$ & 1/2\\ \\
       $1/2\pm\sqrt{1/12}$ & $1/2\pm\sqrt{3/20}$ 
     \end{tabular}
     }
   & 
     \begin{tabular}{c}
       2/7 \\ \\
       5/63 \\ \\
       5/36
     \end{tabular}
   & \cpp{ \small "IM\_QUAD(5)"} \hspace{11em} 7 points, order 5. \\ \hline
\texonly{
 \end{tabular}  
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|} \hline
}
 &&&\cpp{ \small "IM\_QUAD(7)"} \hspace{7em} \mbox{12 points, order 7}\hspace{7em} \\ \hline
\texonly{
 \end{tabular}
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|} \hline
}
 &&&\cpp{ \small "IM\_QUAD(9)"} \hspace{7em} \mbox{20 points, order 9}\hspace{7em} \\ \hline
\texonly{
 \end{tabular}
 \begin{tabular}{|m{2.5cm}|m{6cm}|m{1.2cm}|m{6.5cm}|} \hline
}
 &&&\cpp{ \small "IM\_QUAD(17)"} \hspace{7em} \mbox{70 points, order 17}\hspace{7em} \\ \hline
 \end{tabular}
 \\[0.2cm]

There is also the \cpp{IM\_GAUSS\_PARALLELEPIPED(n,k)} which is a direct product of 1D gauss integrations.\\

\textbf{Important note:} do not forget that \cpp{IM\_QUAD(k)} is exact for polynomials up to degree $k$, and that a $Q_k$ polynomial has a degree of $2*k$. For example, \cpp{IM\_QUAD(7)} cannot integrate exactly the product of two $Q_{2}$ polynomials. On the other hand, \cpp{IM\_GAUSS\_PARALLELEPIPED(2,4)} can integrate exactly that product\ldots

\subsection{Gauss Integration methods on dimension 3}

\begin{tabular}{|m{2.5cm}|m{5.5cm}|m{1.2cm}|m{7.01cm}|} \hline 
  graphic & coordinates \hspace{5em} \begin{tabular}{m{1.7cm}m{1.7cm}m{1.7cm}} x & y & z \end{tabular} & weights & function to call / order \\ \hline
\texonly{
\end{tabular}  
\begin{tabular}{|m{2.5cm}|m{5.5cm}|m{1.2cm}|m{7.01cm}|}
}
   \hline& & &\\
   \icgraphic{2.5cm}{getfemlistintmethodtetrahedron1}{"IM\_TETRAHEDRON(1)"} &
   { \small
     \begin{tabular}{m{1.7cm}m{1.7cm}m{1.7cm}}
       $1/4$ & $1/4$ & $1/4$  
     \end{tabular}
     }
   & 
     { \small \begin{tabular}{c}
       1/6
     \end{tabular} }
   & \cpp{ \small "IM\_TETRAHEDRON(1)"} \hspace{9em} 
     1 point, order 1. \\ \hline
\texonly{
\end{tabular}  
 \begin{tabular}{|m{2.5cm}|m{5.5cm}|m{1.2cm}|m{7.01cm}|}
}
   \hline& & &\\ 
   \icgraphic{2.5cm}{getfemlistintmethodtetrahedron2}{"IM\_TETRAHEDRON(2)"} &
   { \small
     \begin{tabular}{m{1.7cm}m{1.7cm}m{1.7cm}}
       $a$ & $a$ & $a$ \\
       $a$ & $b$ & $a$ \\
       $a$ & $a$ & $b$ \\
       $b$ & $a$ & $a$ 
     \end{tabular}
     }
   & 
     { \small \begin{tabular}{c}
       1/24 \\
       1/24 \\
       1/24 \\
       1/24       
     \end{tabular} }
   & \cpp{ \small "IM\_TETRAHEDRON(2)"} \hspace{7em} 
     \mbox{4 points, order 2} \hspace{7em}
     \mbox{$a = \Frac{5 - \sqrt{5}}{20}$,}\hspace{5em}
     \mbox{$b = \Frac{5 + 3\sqrt{5}}{20}$.}\hspace{5em} \hspace{5em} \hspace{5em}
   \\ \hline
\texonly{
\end{tabular}  
 \begin{tabular}{|m{2.5cm}|m{5.5cm}|m{1.2cm}|m{7.01cm}|}
}
   \hline& & &\\ 
   \icgraphic{2.5cm}{getfemlistintmethodtetrahedron3}{"IM\_TETRAHEDRON(3)"} &
   { \small
     \begin{tabular}{m{1.7cm}m{1.7cm}m{1.7cm}}
       $1/4$ & $1/4$ & $1/4$ \\
       $1/6$ & $1/6$ & $1/6$ \\
       $1/6$ & $1/2$ & $1/6$ \\
       $1/6$ & $1/6$ & $1/2$ \\
       $1/2$ & $1/6$ & $1/6$      
     \end{tabular}
     }
   & 
     { \small \begin{tabular}{c}
       -2/15 \\
       3/40 \\
       3/40 \\
       3/40       
     \end{tabular} }
   & \cpp{ \small "IM\_TETRAHEDRON(3)"} \hspace{7em} 
     \mbox{5 points, order 3} \hspace{7em} \\ \hline
\texonly{ \end{tabular}  
 \begin{tabular}{|m{2.5cm}|m{5.5cm}|m{1.2cm}|m{7.01cm}|}
}
   \hline& & &\\ 
   \icgraphic{2.5cm}{getfemlistintmethodtetrahedron5}{"IM\_TETRAHEDRON(5)"} &
   { \small
     \begin{tabular}{m{1.7cm}m{1.7cm}m{1.7cm}}
       $1/4$ & $1/4$ & $1/4$ \\
       $a$ & $a$ & $a$ \\
       $a$ & $a$ & $c$ \\
       $a$ & $c$ & $a$ \\
       $c$ & $a$ & $a$ \\ 
       $b$ & $b$ & $b$ \\
       $b$ & $b$ & $d$ \\
       $b$ & $d$ & $b$ \\
       $d$ & $b$ & $b$ \\
       $e$ & $e$ & $f$ \\
       $e$ & $f$ & $e$ \\
       $f$ & $e$ & $e$ \\
       $e$ & $f$ & $f$ \\
       $f$ & $e$ & $f$ \\
       $f$ & $f$ & $e$ 
     \end{tabular}
     }
   & 
     { \small \begin{tabular}{c}
       8/405 \\
       h \\
       h \\
       h \\
       h \\      
       i \\
       i \\
       i \\
       i \\
       5/567 \\
       5/567 \\
       5/567 \\
       5/567 \\
       5/567 \\
       5/567
     \end{tabular} }
   & \cpp{ \small "IM\_TETRAHEDRON(5)"} \hspace{7em} 
     \mbox{15 points, order 5} \hspace{7em}
     \mbox{$a = \Frac{7 + \sqrt{15}}{34}$,}
     \mbox{$b = \Frac{7 - \sqrt{15}}{34}$,}\hspace{5em}
     \mbox{$c = \Frac{13 + 3\sqrt{15}}{34}$,}
     \mbox{$d = \Frac{13 - 3\sqrt{15}}{34}$,}\hspace{5em}
     \mbox{$e = \Frac{5 - \sqrt{15}}{20}$,}
     \mbox{$f = \Frac{5 + \sqrt{15}}{20}$,}\hspace{5em}
     \mbox{$h = \Frac{2665 - 14\sqrt{15}}{226800}$,}\hspace{5em} 
     \mbox{$i = \Frac{2665 + 14\sqrt{15}}{226800}$,}\hspace{5em} 
   \\ \hline
 \end{tabular}

 Others methods are:
 \begin{center}
   \begin{tabular}{|lll|}
     \hline name & convex type & nb of points\\
     \hline \cpp{IM\_TETRAHEDRON(6)} & 3D simplex & 24\\
     \cpp{IM\_TETRAHEDRON(8)} & 3D simplex & 43\\
     \cpp{IM\_SIMPLEX4D(3)}   & 4D simplex & 6\\
     \cpp{IM\_HEXAHEDRON(5)}  & 3D parallelepipeded & 14\\
     \cpp{IM\_HEXAHEDRON(9)}  & 3D parallelepipeded & 58\\
     \cpp{IM\_HEXAHEDRON(11)}  & 3D parallelepipeded & 90\\
     \cpp{IM\_CUBE4D(5)}      & 4D parallelepipeded & 24\\
     \cpp{IM\_CUBE4D(9)}      & 4D parallelepipeded & 145\\
     \hline
   \end{tabular}
 \end{center}

\subsection{Direct product of integration methods}

You can use \cpp{ "IM\_PRODUCT(IM1, IM2)"} to produce integration methods on quadrilateral or prisms. It gives the direct product of two integration mathods. For instance \cpp{IM\_GAUSS\_PARALLELEPIPED(2,k)} is an alias for \cpp{IM\_PRODUCT(IM\_GAUSS1D(2,k),IM\_GAUSS1D(2,k))} and ca be use instead of the \cpp{IM\_QUAD} integrations.

\subsection{Composite integration methods}

\begin{figure}[H]
  \begin{center}
    \icgraphic{5cm}{getfemlistintmethodtriangle2comp}{"IM\_STRUCTURED\_COMPOSITE(IM\_TRIANGLE(2), 3)"}
  \end{center}
  \caption{ \it composite method \cpp{ "IM\_STRUCTURED\_COMPOSITE(IM\_TRIANGLE(2), 3)"}} 
  \label{fig:triangle_comp}
\end{figure}


use \cpp{ "IM\_STRUCTURED\_COMPOSITE(IM1, S)"} to copy \cpp{ IM1} on an element with \cpp{ S} subdivisions. The resulting integration method has the same order but with more points. This could be more stable to use composite method rather than to improve the order of the method. Those methods have to be used also with composite elements. Most of the time for composite element, it is preferable to choose the basic method \cpp{IM1} with no points on the boundary (because the gradient coulb be not defined on the boundary of sub-elements). 


For the HCT element, it is advised to use the \cpp{IM\_HCT\_COMPOSITE(im)} composite integration (which split the original triangle into 3 sub-triangles).




\newpage

\section{Appendix C. Some basic computations between reference and real elements}
\subsection{Volume integral}
One has
\equat{\int_T f(x) dx = \int_{T'} f'(x') |\text{vol}\left(\Frac{\partial \tau(x')}{\partial x'_0} ;\Frac{\partial \tau(x')}{\partial x'_1}; ...; \Frac{\partial \tau(x')}{\partial x'_{P-1} }\right)| dx'.}
Denoting $J_{\tau}(x')$ the jacobian
\begin{center} \texonly{$ \fbox}{$\hspace{1em} J_{\tau}(x') := |\text{vol}\left(\Frac{\partial \tau(x')}{\partial x'_0} ;\Frac{\partial \tau(x')}{\partial x'_1}; ...; \Frac{\partial \tau(x')}{\partial x'_{P-1} }\right)| = (\mbox{det}(K(x')^T K(x')))^{1/2},\hspace{1em}$} \texonly{$}\end{center}
one finally has
\begin{center} \texonly{$ \fbox}{$\hspace{1em} \ds \int_T f(x) dx = \int_{T'} f'(x')  J_{\tau}(x')dx'.\hspace{1em}$} \texonly{$} \end{center}
When $P = N$, the expression of the jacobian reduces to $J_{\tau}(x') = |\mbox{det}(K(x'))|$.

\subsection{Surface integral}
With $\Gamma$ a part of the boundary of $T$ a real element and $\Gamma'$ the corresponding boundary on the reference element $T'$, one has
\begin{center} \texonly{$ \fbox}{$\hspace{1em} \ds \int_{\Gamma} f(x) d\sigma = \int_{\Gamma'} f'(x') \|B(x'){\mathbf n'}\| J_{\tau}(x') d\sigma',\hspace{1em}$} \texonly{$} \end{center}
where ${\mathbf n}'$ is the unit normal to $T'$ on $\Gamma'$. In a same way
\begin{center} \texonly{$ \fbox}{$\hspace{1em} \ds \int_{\Gamma} F(x).{\mathbf n} d\sigma = \int_{\Gamma'} F'(x').(B(x'){\mathbf n}') J_{\tau}(x') d\sigma'.\hspace{1em}$} \texonly{$} \end{center}

\subsection{Derivative computation}
One has
\equat{\nabla f(x) = B(x') \nabla'\,f'(x').}
\subsection{Second derivative computation}
Denoting 
\equat{\nabla^2 f = ({\Frac{\partial^2 f}{\partial x_i \partial x_j}})_{ij},}
the $N \times N$ matrix and
\equat{X'(x') = \sum_{k = 0}^{N-1} \nabla'^2 \tau_k(x') \Frac{\partial f}{\partial x_k}(x) = \sum_{k = 0}^{N-1} \sum_{i = 0}^{P-1} \nabla'^2 \tau_k(x') B_{ki} \Frac{\partial f'}{\partial x'_i}(x'),}
the $P \times P$ matrix, then
\equat{\nabla'^2 f'(x') = X'(x') + K(x')^T \nabla^2 f(x) K(x'),}
and thus
\equat{\nabla^2 f(x) = B(x') (\nabla'^2 f'(x') - X'(x')) B(x')^T.}

In order to have uniform methods for the computation of elementary matrices, the Hessian is computed as a column vector $H f$ whose components are $\Frac{\partial^2 f}{\partial x^2_0}, {\Frac{\partial^2 f}{\partial x_1 \partial x_0}}, ... {\Frac{\partial^2 f}{\partial x^2_{N-1}}}$.
Then, with $B_2$ the $P^2 \times P$ matrix defined as
\equat{(B_2(x'))_{ij} = \sum_{k = 0}^{N-1} \Frac{\partial^2 \tau_k(x')}{\partial x'_{i / P} \partial x'_{i \mbox{ mod } P} } B_{kj}(x'),}
and $B_3$ the $N^2 \times P^2$ matrix defined as
\equat{(B_3(x'))_{ij} = B_{i / N, j / P}(x') B_{i \mbox{ mod } N, j \mbox{ mod } P}(x'),}
one has
\begin{center} \texonly{$ \fbox}{ $H f(x) = B_3(x') \left(H'\,f'(x') - B_2(x')\nabla'\,f'(x')\right). $} \texonly{$} \end{center}

\subsection{Example of elementary matrix} \label{elmminst}

Assume one needs to compute the elementary ``matrix'':
\equat{t(i_0, i_1, ..., i_7) = \int_{T} \varphi_{i_1}^{i_0}\; \partial_{i_4} \varphi_{i_3}^{i_2}\; \partial^2_{i_7 / P, i_7 \mbox{ mod } P} \varphi_{i_6}^{i_5} dx,}
The computations to be made on the reference elements are
\equat{ t'_0(i_0, i_1, ..., i_7) = \int_{T'} \varphi'_{i_1}^{i_0}\; \partial_{i_4} \varphi'_{i_3}^{i_2}\; \partial^2_{i_7 / P, i_7 \mbox{ mod } P} \varphi'_{i_6}^{i_5}  J(x') dx',}
and
\equat{t'_1(i_0, i_1, ..., i_7) = \int_{T'} \varphi'_{i_1}^{i_0}\; \partial_{i_4} \varphi'_{i_3}^{i_2}\; \partial_{i_7} \varphi'_{i_6}^{i_5}  J(x') dx',}
Those two tensor can be computed once on the whole reference element if the geometric transformation is linear (because $J(x')$ is constant). If the geometric transformation is non-linear, what has to be stored is the value on each integration point. To compute the integral on the real element a certain number of reductions have to be made:
\begin{itemize}
    \item Concerning the first term ($\varphi_{i_1}^{i_0}$) nothing.
    \item Concerning the second term ($\partial_{i_4} \varphi_{i_3}^{i_2}$) a reduction with respect to $i_4$ with the matrix $B$.
    \item Concerning the third term ($\partial^2_{i_7 / P, i_7 \mbox{ mod } P} \varphi_{i_6}^{i_5}$) a reduction of $t'_0$ with respect to $i_7$ with the matrix $B_3$ and a reduction of $t'_1$ with respect also to $i_7$ with the matrix $B_3B_2$
 \end{itemize}
 The reductions are to be made on each integration point if the geometric transformation is non-linear. Once those reductions are done, an addition of all the tensor resulting of those reductions is made (with a factor equal to the load of each integration point if the geometric transformation is non-linear).

 If the finite element is non-$\tau$-equivalent, a supplementary reduction of the resulting tensor with the matrix $M$ has to be made.



\begin{thebibliography}{99}
% \bibliographystyle{apalike}
% \bibliographystyle{plain}
% \bibliography{all}

\bibitem{bank1983}
  R.E. Bank, A.H. Sherman, A. Weiser
  {\it Refinement algorithms and data structures for regular local mesh refinement},
  in Scientific Computing IMACS, Amsterdam, North-Holland, pp 3-17, (1983).

\bibitem{ciarlet1978}
  P.G.. Ciarlet,
  {\it The finite element method for elliptic problems}, Studies in Mathematics and its Applications vol. 4 (1978), North-Holland.

\bibitem{dh-to1984} 
  G. Dhatt, and  G. Touzot
  {\it The Finite Element Method Displayed}, 
  J. Wiley \& Sons,  New York, (1984).

\bibitem{EncyclopCubature}
  R. Cools
  {\it An Encyclopaedia of Cubature Formulas}, J. Complexity, \WEB{http://www.cs.kuleuven.ac.be/\tild ines/research/ecf/ecf.html}{http://www.cs.kuleuven.ac.be/\tilda ines/research/ecf/ecf.html}
  
\bibitem{Xfem}
  N. Mos, J. Dolbow and T. Belytschko
  {\it A finite element method for crack growth without remeshing },
  Int. J. Num. Meth. Engng. 46 (1999), 131-150.  

\bibitem{nedelec1991}
  J.-C. Nedelec,
  {\it Notions sur les techniques d'{\'e}l{\'e}ments finis}, Ellipses, SMAI, Math{\'e}matiques \& Applications n$^o7$, (1991).

\bibitem{remacle2002}
  J-F. Remacle, M. Shephard,
  {\it An algorithm oriented database}
  Int. J. Num. Meth. Engng. 58 (2003), 349-374.  


\bibitem{so-se-do2004}
  P. Solin, K. Segeth, I. Dolezel,
  {\it Higher-Order Finite Element Methods}, Chapman and Hall/CRC, Studies in advanced mathematics, 2004.

\end{thebibliography}

% \W \section*{Index}
% \texorhtml{\printindex}{\label{gfmindex}\htmlprintindex}

\end{document}
