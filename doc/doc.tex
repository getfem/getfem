\documentclass[10pt,a4paper]{doc}

\usepackage{fancyheadings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{psfig}
\usepackage{here}
\usepackage{array}
\usepackage{graphicx}
\usepackage{eepic,epic}
\usepackage{alltt}
% \usepackage[french]{babel}
% \usepackage[dvips]{epsfig}


\oddsidemargin -1.0cm
\evensidemargin -1.0cm
\topmargin -2.2cm
\textheight 24.7cm
\textwidth 18cm
\headheight 1.0cm

\newfont{\eufmtwelve}   {eufm10 scaled \magstep1}
\newfont{\eufmten}      {eufm10 }
\newfont{\eufmnine}     {eufm9 }
\newfont{\eufmeight}    {eufm8 }
\newfont{\eufmseven}    {eufm7 }
\newfont{\eufmsix}      {eufm6 }
\newfont{\eufmfive}     {eufm5 }
\newfont{\eusmtwelve}   {eusm10 scaled \magstep1}
\newfont{\eusmten}      {eusm10}
\newfont{\eusmnine}     {eusm9 }
\newfont{\eusmeight}    {eusm8 }
\newfont{\eusmseven}    {eusm7 }
\newfont{\eusmsix}      {eusm6 }
\newfont{\eusmfive}     {eusm5 }
\newfont{\msbmtwelve}   {msbm10 scaled \magstep1}
\newfont{\msbmeight}    {msbm8}

\newcommand{\udl}{\underline}
\newcommand{\udll}[1]{{\udl{\udl{#1}}}}
\newcommand{\udlll}[1]{{\udl{\udl{\udl{#1}}}}}
\newcommand{\Reel}{{\mbox{\msbmtwelve R}}}      % L'ensemble des reels.
\newcommand{\reel}{{\mbox{\msbmeight R}}}       % L'ensemble des reels.
\newcommand{\Rn}{\Reel^{n}}
\newcommand{\Rtrois}{\Reel^{3}}
\newcommand{\Complex}{\mbox{\msbmtwelve C}}     % L'ensemble des complexes.
\newcommand{\Naturel}{\mbox{\msbmtwelve N}}  % L'ensemble des entiers naturels.
\renewcommand{\emptyset}{\mbox{$\circ$\hspace{-.50em}/}}  % ensemble vide.
\newcommand{\Cont}{{\cal C}}            % L'ensemble des fonctions continues
\newcommand{\Cinf}{{\cal C}^{\infty}}   % L'ensemble des fonction C-infinies
\renewcommand{\vec}[1]{\overrightarrow{\!\!#1}}
\newcommand{\subsetcont}{{\subset\hspace{-.6em}_{\scriptscriptstyle >} }}
\newcommand{\Frac}[2]{{\ds \frac{\ds #1}{\ds #2}}}
\newcommand{\interior}[1]{{\stackrel{\circ}{#1}}}
\newcommand{\cqfd}{{\hfill\rule{2.5mm}{2.5mm}}}
\newcommand{\vectwo}[2]{{\left(\hspace{-.5em}\begin{array}{c} {#1} \\ {#2}
     \end{array}\hspace{-.5em}\right)}}
\newcommand{\vecthree}[3]{{\left(\hspace{-.5em}\begin{array}{c} {#1}
     \\ {#2} \\ {#3} \end{array}\hspace{-.5em}\right)}}
\newcommand{\vecfive}[5]{{\left(\hspace{-.5em}\begin{array}{c} {#1}
     \\ {#2} \\ {#3} \\ {#4} \\ {#5} \end{array}\hspace{-.5em}\right)}}
\def\infess{\mathop{\iflanguage{english}{\mbox{ess$\,$inf}}{\mbox{inf$\,$ess}}}}
\def\supess{\mathop{\iflanguage{english}{\mbox{ess$\,$sup}}{\mbox{sup$\,$ess}}}}
\def\essinf{\mathop{\iflanguage{english}{\mbox{ess$\,$inf}}{\mbox{inf$\,$ess}}}}
\def\esssup{\mathop{\iflanguage{english}{\mbox{ess$\,$sup}}{\mbox{sup$\,$ess}}}}
\def\aplim{\mathop{\mbox{ap$\,$lim}}}
\def\aplimsup{\mathop{\mbox{ap$\,$lim$\,$sup}}}
\def\apliminf{\mathop{\mbox{ap$\,$lim$\,$inf}}}
\def\convto{\mathop{\hbox{\rightarrowfill}}} % converge vers.
\newcommand{\rightgap}{{]\hspace{-0.12em}]}}
\newcommand{\leftgap}{{[\hspace{-0.12em}[}}
\newcommand{\gapof}[1]{{\leftgap {#1} \rightgap}}
\newcommand{\restrictiona}[1]
{{ \begin{picture}(13,10) \put(-1,-4){$\mid_{#1}$} \end{picture}
}} % Le signe "Restriction sur #1"

\def\Indic{\mbox{1\hspace{-0.20em}I}}   % Fonction l'indicatrice

\def\bar3{|\hspace{-1pt}\|} % 3bar verticaux pour les normes matricielles.
\def\fleche{\overrightarrow} %fleche en haut
\def\cvfaible{\rightharpoonup} %fleche cv faiblement
\def\longmapsto
{ \begin{picture}(0,10)
  \put(0,0){$\scriptstyle{\vdash}$} \end{picture} \mbox{$\longrightarrow$}
} 

\def\build#1_#2^#3{\mathrel{
 \mathop{\kern 0pt#1}\limits_{#2}^{#3}}} % Ecrire en dessous et dessus un symbole.

\def\Dist{\mbox{\eusmtwelve D}} %signe de distribution
\def\dist{\mbox{\eusmten D}} %signe de distribution


%definition de commandes utilses
\newcommand{\ds}{\displaystyle}
\newcommand{\rc}{{\par}}
\newcommand{\rcc}{{\par\medskip}}
\newcommand{\rccc}{{\par\bigskip}}


%definition des environnements theoreme, lemme, ...
\usepackage{boxedminipage}
% \newenvironment{largebox}
%   { \rc\noindent \begin{boxedminipage}[t]{\textwidth} }
%   { \end{boxedminipage}  \rccc\noindent }
\newenvironment{largebox}
  { \rc\noindent \begin{boxedminipage}[t]{\linewidth} }
  { \end{boxedminipage}  \rccc\noindent }


\newtheorem{ltheoreme}{Th\'eor\`eme}
\newenvironment{theoreme}
  { \begin{largebox} \begin{ltheoreme} }
  { \end{ltheoreme} \end{largebox} }
\newtheorem{lproposition}{Proposition}
\newenvironment{proposition}
  { \begin{largebox} \begin{lproposition} }
  { \end{lproposition} \end{largebox} }
\newtheorem{llemme}{Lemme}
\newenvironment{lemme}
  { \begin{largebox} \begin{llemme} }
  { \end{llemme} \end{largebox} }
\newtheorem{ldefinition}{D\'efinition}
\newenvironment{definition}
  { \begin{largebox} \begin{ldefinition} }
  { \end{ldefinition} \end{largebox} }
\newtheorem{lhypothese}{Hypoth\`ese}
\newenvironment{hypothese}
  { \begin{largebox} \begin{lhypothese} }
  { \end{lhypothese} \end{largebox} }
\newtheorem{lcorollaire}{Corollaire}
\newenvironment{corollaire}
  { \begin{largebox} \begin{lcorollaire} }
  { \end{lcorollaire} \end{largebox} }
\newenvironment{remarque}
  { \begin{largebox} {\bf \udl{Remarque} : }}
  { \end{largebox} }

\newcounter{numberofprobl}
\setcounter{numberofprobl}{1}

\newlength{\compteurtpourprobla}
\newlength{\compteurtpourproblb}
\newenvironment{caseeqnarray}[1]
  {
   $${#1}
   \settowidth{\compteurtpourprobla}{${#1}\left\{\right.$}
   \setlength{\compteurtpourproblb}{\textwidth}
   \addtolength{\compteurtpourproblb}{-1\compteurtpourprobla}
   \settowidth{\compteurtpourprobla}{$\;$}
   \addtolength{\compteurtpourproblb}{-1\compteurtpourprobla}
   \left\{ \begin{minipage}[l]{\compteurtpourproblb}
   \vspace{-1em} \begin{eqnarray}
  }
  { \end{eqnarray} \end{minipage} \right. $$}


\newtheorem{hypothesis}{Hypothesis}
\newtheorem{prop}{Proposition}
\newtheorem{defi}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}


% pour plus tard ...
% \DeclareGraphicsRule{ps.Z}{eps}{ps.bb}{`zcat #1}
% \DeclareGraphicsRule{eps.Z}{eps}{eps.bb}{`zcat #1}
% \DeclareGraphicsRule{ps.gz}{eps}{ps.bb}{`gunzip #1}
% \DeclareGraphicsRule{eps.gz}{eps}{eps.bb}{`gunzip #1}
\newenvironment{librarydescription}[1]
  { \part{#1} \setcounter{chapter}{0} \section*{Presentation of #1} }
  { }

\newenvironment{filedescription}[3]
  { \chapter{#2}
    {\LARGE \begin{alltt} \begin{center} #3 \end{center} \end{alltt}}
    {\large \begin{center} Part of the #1 \end{center} }
  }
  { }

\newenvironment{filepresentation}
  { \section{Presentation} }
  {  }

\newenvironment{fileinfocomp}
  { \section{Complementary information} }
  {  }

\newenvironment{functiondescription}[1]
  { \section{Function #1} }
  {  }

\newenvironment{functionsdescription}[1]
  { \section{#1} }
  {  }

\newenvironment{classdescription}[1]
  { \section{Class #1} }
  {  }

\newenvironment{pexample}[1]
  { \section{#1} }
  {  }

\newenvironment{classdeclaration}
  { \begin{tabular}{|m{0.42\linewidth}|m{0.524\linewidth}|} \hline 
      Constructor & Description \\ \hline \hline }
  { \end{tabular} \\ }

\newenvironment{classmembersdescription}
  { \begin{tabular}{|m{0.3\linewidth}|m{0.15\linewidth}|m{0.47\linewidth}|} \hline 
      Name & Type & Description \\ \hline \hline }
  { \end{tabular} \\ }


\newcommand{\functiondecl}[1]{ \begin{alltt} \hspace{2em} #1 \end{alltt} }
\newcommand{\functiondesc}[1]{ $\;$\\[0.2cm] #1 }
\newcommand{\comitem}[1]{ \subsection{ #1 } }
\newcommand{\comsubitem}[1]{ \subsubsection{ #1 } }
\newcommand{\classdecl}[2]{ \mbox{ #1 } & #2 \\ \hline }
\newcommand{\classdesc}[1]{ $\;$\\[0.3cm] #1 \\[0.3cm] }
\newcommand{\classmember}[3]{ #1 & #2 & #3 \\ \hline }
\begin{document}

$\;$\\[3cm]\thispagestyle{empty}

{\begin{center} \Large Basic documentation of \\[2cm]

\Huge \bf GETFEM++ \end{center}} \newpage

\noindent Copyright (C) 2001.\\ \\
This is a part of GETFEM++.\\ \\
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as  published by the Free Software Foundation; version 2 of the License.\\ \\
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\\ \\
You should have received a copy of the GNU General Public License  along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\\ \\

\tableofcontents

 \begin{librarydescription}{The Dynamic Array Library}
   The Dynamic Array Library (dal) is a library of containers
   and algorithms on containers. Thoses containers are initialy adapted
   to store data for meshes, but they are also of larger
   interest. The library is build on a container which is \\ \\
   dal::dynamic\_array$<$T$>$. \\ \\
   This container is very similar to std::vector$<$T$>$ of the Standard
   Template Library. The major difference
   is that memory is allocated by block and
   the allocation is automatic when an acces to a non existing element 
   is called. \\ \\
   Others containers like dal::dynamic\_tas$<$T$>$ or
   dal::dynamic\_tree\_sorted$<$T$>$ allow to add or delete elements
   in an array. Particularily, dal::dynamic\_tree\_sorted$<$T$>$ combines
   the random access of an array and the logarithmic search and insertion
   in a balanced sorted tree.
   \end{librarydescription}
   \begin{filedescription}{ Dynamic Array Library }{ Incompatibility resolutions }
        { dal\_std.h }
     This file load the very standard c++ header files and solve as much
     as possible the incompatibility between differents
     configurations. \\ \\
     - It assures the existence of the functions \\ \\
       template$<$class T$>$ std::abs(T) \\
       template$<$class T$>$ std::sqr(T) \\ \\
     - It defines fixed size type of integers : \\ \\
       int8\_type; uint8\_type; \\
       int16\_type; uint16\_type; \\
       int32\_type; uint32\_type; \\ \\
     - The macro
       \begin{alltt} __GETFEM_VERIFY \end{alltt}
       allows to switch on or off verifications on libraries,
       such as verification of range on arrays, on vectors ...
    \end{filedescription} 
 \begin{filedescription}{ Dynamic Array Library }
             { Basic dynamic array }
             { dal\_basic.h }
    \begin{filepresentation}
      Defines the basic container of the library which is 
      dal::dynamic\_array$<$T, pks$>$. This container is virtually an
      infinite array of element of type T. When a random acces tab[i] is
      called, a control is made on i and an allocation is made if 
      needed. The allocation is made by blocks of n elements, where
      $n = 2^{pks}$.
    \end{filepresentation}
  
 \begin{classdescription}{dna\_iterator$<$T, pks$>$}
   \begin{classdeclaration}
   \classdecl{dna\_iterator$<$T, pks$>$ it(dna, i);}
    {give an iterator on the dynamic array dna which points on element i}
   \classdecl{dna\_iterator$<$T, pks$>$ it;}{undefined iterator }
   \end{classdeclaration}
   \classdesc{Iterator on container dal::dynamic\_array$<$T, pks$>$. 
   pks is optional, assumed to be 5.}
   \begin{classmembersdescription}
     \classmember{$++$it, it$++$}{method}{next element }
     \classmember{$--$it, it$--$}{method}{previous element }
     \classmember{index()}{const method}{index of pointed element }
     \classmember{it += n}{method}{go n elements forward }
     \classmember{it +  n}{const method}
                 {iterator which points n elements forward }
     \classmember{it -= n}{method}{go n elements backward }
     \classmember{it -  n}{const method}
                 {iterator which points n elements backward }
     \classmember{*it}{const method}{element pointed by it}
     \classmember{it1 - it2}{const method}{distance between it1 and it2}
     \classmember{it[n]}{const method}{equivalent to *(it+n)}
     \classmember{==, !=}{const method}{equality tests}
     \classmember{$<$}{const method}{inequality test}
   \end{classmembersdescription}
  \end{classdescription} 
 \begin{classdescription}{dna\_const\_iterator$<$T, pks$>$}
   \begin{classdeclaration}
   \classdecl{dna\_const\_iterator$<$T, pks$>$ cit(dna, i);}
   {give a const iterator on the dynamic array dna which points
    on element i}
   \classdecl{dna\_const\_iterator$<$T, pks$>$ cit(it);}
          {build a const iterator from an iterator}
   \classdecl{dna\_const\_iterator$<$T, pks$>$ cit;}{undefined iterator }
   \end{classdeclaration}
   \classdesc{Iterator on container dal::dynamic\_array$<$T$>$.
              Same members as dna\_iterator$<$T, pks$>$}
  \end{classdescription} 
 \begin{classdescription}{dynamic\_array$<$T, pks$>$}
   \begin{classdeclaration}
     \classdecl{dynamic\_array$<$T, pks$>$ tab;}
               {array initialized with 0 element}
     \classdecl{dynamic\_array$<$T, pks$>$ tab(n);}
               {array initialized with n element}
   \end{classdeclaration}
   \classdesc{Container dal::dynamic\_array$<$T, pks$>$. This container act
          as an array of element of type T. The allocation is made by pack
              of $2^{pks}$ elements. $pks$ is an optional parameter.}
   \begin{classmembersdescription}
     \classmember{size()}{const method}{number of allocated elements}
     \classmember{begin()}{(const) method}{iterator on first element}
     \classmember{end()}{(const) method}{iterator on last element 
         allocated+ 1. This is in general different that the last
         accessed element, be carrefull.}
     \classmember{tab[i]}{(const) method}{reference to element i}
     \classmember{swap(i,j)}{method}{swap element i and j}
     \classmember{clear()}{method}{desallocate all elements}
     \classmember{swap(tab)}{method}{swap arrays *this and tab}
     \classmember{memsize()}{const method}{evaluate the total
                  memory occupated by the array}
   \end{classmembersdescription}
  \end{classdescription} 
 \begin{pexample}{Example of code}
  If T is any type (with or without trivial constructor/destructor, 
  and with constructor T(0) and T(1)), the
  following code is valid:
 \begin{alltt}
  \#include<dal_basic.h>

  dal::dynamic_array<T> tab; \\
  tab[50] = T(0); // to be sure to have at least 50 elements \\
  std::fill(tab.begin(), tab.end(), T(0)); // at least 50 elements are initialized \\ \\
  dal::dynamic_array<T>::iterator it = tab.begin(); 
  dal::dynamic_array<T>::iterator ite = it + 50;  \\
  for( ; it != ite; ++it)
    { *it = T(1); } // only the 50 first elements are changed.
 \end{alltt}
 
  \end{pexample}  \end{filedescription} 
 \begin{librarydescription}{ Basic GEOmetric Tool }
   The basic geometric tool is ...
   \\ \\
  \end{librarydescription} 
 \begin{filedescription}{ Basic GEOmetric Tool }
             { Plain Polynomials with several variables }
             { bgeot\_poly.h }
    \begin{filepresentation}
      This unit deals with the plain polynomials with
      several variables. The coefficients are abstract ($<$T$>$).
      A polynomial of $n$ variables and degree $d$ is stored in a vector
       of $\alpha_d^n$ components.
    \end{filepresentation}
  
 \begin{functiondescription}{alpha}
   \functiondecl{size\_type alpha(short\_type n, short\_type d)}
   \functiondesc{Return the value of $\Frac{(n+p)!}{n!p!}$ which is the
     number of monomials of a polynomial of $n$ variables and degree $d$.}
  \end{functiondescription} 
 \begin{classdescription}{power\_index}
   \begin{classdeclaration}
   \classdecl{power\_index pi(short\_type n);}
             {power index for n variables}
   \classdecl{power\_index pi;}{ undefined power index }
   \end{classdeclaration}
   \classdesc{Vector of integer (16 bits type) which represent the powers
     of a monomial}
   \begin{classmembersdescription}
     \classmember{$++$pi, pi$++$}{method}
                 { Gives the next power index }
     \classmember{$--$pi, pi$--$}{method}
                 { Gives the previous power index }
     \classmember{global\_index}{const method}
                 { Gives the global number of the index
                   (i.e. the position of the corresponding monomial. }
     \classmember{degree()}{method}
                 { Gives the degree. }  
   \end{classmembersdescription}
  \end{classdescription} 
 \begin{classdescription}{polynomial$<$T$>$}
   \begin{classdeclaration}
   \classdecl{polynomial$<$T$>$ P;}{Undefined polynomial}
   \classdecl{polynomial$<$T$>$ P(n,d);}
     {Polynomial of n variables and degree d.}
   \classdecl{polynomial$<$T$>$ P(n,d,k);}
     {Polynomial of n variables and degree d, initialized with the monomial
      which represent the k$^{\mbox{th}}$ variable to the power 1.}
   \end{classdeclaration}
   \classdesc{Polynomial with coefficient of class $<$T$>$.}
    \begin{classmembersdescription} 
 \classmember{degree()}{const method}
                 { Gives the degree of the polynomial }
  
 \classmember{real\_degree()}{const method}
        { gives the degree of the polynomial, considering only
          non-zero coefficients }
  
 \classmember{dim()}{const method}
                 { Gives the dimension (number of variables) }
  
 \classmember{change\_degree(d)}{method}
        { Change the degree of the polynomial to d. }
  
 \classmember{add\_monomial(a, pi)}{method}
        { Add to the polynomial a monomial of coefficient
          a and correpsonding to the power index pi. }
  
 \classmember{P += Q}{method}
        { Add Q to P. P contains the result. }
  
 \classmember{P -= Q}{method}
        { Substract Q to P. P contains the result. }
  
 \classmember{P + Q}{const method}{ Add Q to P. }
  
 \classmember{P - Q}{const method}{ Substract Q to P. }
  
 \classmember{P *= Q}{method}
        { Multiply P with Q. P contains the result. }
  
 \classmember{P * Q}{method}{ Multiply P with Q. }
  
 \classmember{direct\_product(Q)}{method}
        { Product of P and Q considering
 that variables of Q come after variables of P. P contains the result }
  
 \classmember{P *= a}{method}
        { Multiply P with the scalar a. P contains the result. }
  
 \classmember{P * a}{method}{ Multiply P with the scalar a. }
  
 \classmember{P /= a}{method}
        { Divide P with the scalar a. P contains the result. }
  
 \classmember{P / a}{method}{ Divide P with the scalar a. }
  
 \classmember{derivative(k)}{method}
        { Derivative of P with respect to the variable k.
          P contains the result. }
  
 \classmember{one()}{method}
        { Makes P = 1. }
  
 \classmember{eval(it)}{const method}
        { Evaluate the polynomial. "it" is an iterator
     pointing to the list of variables. A Horner scheme is used.}
  
 \classmember{o $<<$ P}{operator}
        { Print P to the output stream o. for instance cout $<<$ P; }
  
  \end{classmembersdescription} \end{classdescription} 
 \begin{pexample}{Example of code}
   the following code is valid :
   \begin{alltt}
   \#include<bgeot_poly.h>

   bgeot::polynomial<double> P, Q;
   P = bgeot::polynomial<double>(2,2,1); // P = x
   Q = bgeot::polynomial<double>(2,2,2); // Q = y
   P += Q; // P is equal to x+y.
   P *= Q; // P is equal to xy + y^2
   
   bgeot::power\_index pi(P.dim());
   bgeot::polynomial<double>::const\_iterator ite = Q.end();
   bgeot::polynomial<double>::const\_iterator itb = Q.begin();
   for ( ; itb != ite; ++itb, ++pi)
     if (*itq != double(0))
       cout "there is x to the power " << pi[0] << " and y to the power "
             << pi[1] << " and a coefficient " << *itq << endl;
   \end{alltt}
  \end{pexample} 
 \begin{fileinfocomp}
     \comitem{Monomials ordering}
       The constant coefficient is placed first with the index 0.\\
       Two monomials of different degrees are ordered following
       there respective degree.
       If two polynoms have the same degree, they are ordered with the
       degree of the polynomials without the n firsts variables which
       have the same degree. The index of the monomial
       $$ x_0^{i_0}x_1^{i_1} ... x_{n-1}^{i_{n-1}} $$
       is then
       $$ \alpha_{d-1}^{n} + \alpha_{d-i_0-1}^{n-1} 
          + \alpha_{d-i_0-i_1-1}^{n-2} + ... + \alpha_{i_{n-1}-1}^{1}, $$
       where $d = \sum_{l=0}^{n-1} i_l$ is the degree of the monomial.
       (by convention $\alpha_{-1}^{n} = 0$).
     \comitem{Dealing with the vector of power}
        The answer to the question : what is the next and previous
        monomial of $x_0^{i_0}x_1^{i_1} ... x_{n-1}^{i_{n-1}}$ in the
        vector is the following :\\
        To take the next coefficient, let $l$ be the last index between 0
        and $n-2$ such that $i_l \ne 0$ ($l = -1$ if there is not), then
        make the operations $a = i_{n-1}; i_{n-1} = 0; i_{l+1} = a+1;
        \mbox{ if } l \ge 0 \mbox{ then } i_l = i_l - 1$.\\
        To take the previous coefficient, let $l$ be the last index 
        between 0 and $n-1$ such that $i_l \ne 0$ (if there is not, there
        is no previous monomial) then make the operations $a = i_l;
        i_l = 0; i_{n-1} = a - 1; \mbox{ if } l \ge 1 \mbox{ then } 
        i_{l-1} = i_{l-1} + 1$.
     \comitem{Direct product multiplication}
        This direct product multiplication of P and Q is the
        multiplication considering that the variables of Q follow the
        variables of P. The result is a polynomial with the number of
        variables of P plus the number of variables of Q.\\
        The resulting polynomials have a smaller degree.\\
     \comitem{Horner scheme to evaluate polynomials}
        To do ...
   \end{fileinfocomp}
  \end{filedescription} 
 \begin{filedescription}{ Basic GEOmetric Tool }
             { Plain Vectors }
             { bgeot\_vector.h }
    \begin{filepresentation}
      This unit deals with the plain vectors of arbitrary base type
      ($<$T$>$). It as been build especially for small vectors.
      The copy operator is a true copy (i.e. no "sharing" copy).
      The classes are very similar to std::vector, with additional
      classical linear algebraic operations.
    \end{filepresentation}
  
 \begin{classdescription}{fsvector}
   \begin{classdeclaration}
   \classdecl{fsvector$<$T,n$>$ V;}{ Fixed size vector of n components}
   \classdecl{fsvector$<$T,2$>$ V(a0, a1);}{ Vector of 2 components,
                                            initialized with a0 and a1}
   \classdecl{fsvector$<$T,3$>$ V(a0, a1, a2);}{ Vector of 3 components,
                                          initialized with a0, a1 and a2}
   \classdecl{fsvector$<$T,4$>$ V(a0, a1, a2, a3);}
           { Vector of 4 components, initialized with a0, a1, a2 and a3}
   \end{classdeclaration}
   \classdesc{ Container type representing a fixed size vector of n
               components. The interest is that
               alebraic operations are optimized (no loop).}
    \begin{classmembersdescription} 
 \classmember{iterator}{member type}{ Iterator type, of T * type }
  
 \classmember{const\_iterator}{member type}
                     { Constant iterator type, of const T * type }
  
 \classmember{begin()}{(const) method}
   { Return the iterator or const\_iterator on the first component }
  
 \classmember{end()}{(const) method}
   { Return the iterator or const\_iterator over the last component }
  
 \classmember{size()}{const method}
   { Return the size of the vector (i.e. n) }
  
 \classmember{empty()}{const method}
   { Return true if the vector has no component (n = 0) }
  
 \classmember{V[i]}{(const) method}
   { Return a reference on the component i of the vector }
  
 \classmember{V *= a}{method}
   { Multiply the vector with the scalar a. V contains the result. }
  
 \classmember{V /= a}{method}
   { Divide the vector with the scalar a. V contains the result. }
  
 \classmember{V += W}{method}
   { Add vector W to vector V. V contains the result. }
  
 \classmember{V -= W}{method}
   { Substract vector W to vector V. V contains the result. }
  
 \classmember{V * a}{operator}
   { Multiply V by the scalar a }
  
 \classmember{a * V}{operator}
   { Multiply V by the scalar a }
  
 \classmember{V / a}{operator}
   { Divide V by the scalar a }
  
 \classmember{V + W}{operator}
   { Add V and W}
  
 \classmember{V - W}{operator}
   { Substract W to V}
  
 \classmember{-V}{operator}
   { Gives the opposite of V}
  
 \classmember{+V}{operator}
   { Gives  V}
  
 \classmember{vect\_sp(V,W)}{function}
   { Scalar product between V and W}
  
   \end{classmembersdescription} \end{classdescription} 
 \begin{classdescription}{vsvector}
   \begin{classdeclaration}
   \classdecl{vsvector$<$T$>$ V;}{ Variable size vector. }
   \classdecl{vsvector$<$T$>$ V(n);}
     { Variable size vector initialized with n components. }
   \classdecl{vsvector$<$T$>$ V(a0, a1);}
      { Vector initialized with 2 components equal to a0 and a1}
   \classdecl{vsvector$<$T$>$ V(a0, a1, a2);}
      { Vector initialized with 3 components equal to a0, a1 and a2}
   \classdecl{vsvector$<$T$>$ V(a0, a1, a2, a3);}
      { Vector initialized with 4 components equal to a0, a1, a2 and a3} 
   \end{classdeclaration}
   \classdesc{ Container type representing a vector with an arbitrary 
               number of components. Directly derived from std::vector }
   \begin{classmembersdescription}
   \classmember{iterator}{member type}{ Iterator type, of T * type }
   \classmember{const\_iterator}{member type}
                     { Constant iterator type, of const T * type }
   \classmember{begin()}{(const) method}
   { Return the iterator or const\_iterator on the first component }
   \classmember{end()}{(const) method}
   { Return the iterator or const\_iterator over the last component }
   \classmember{size()}{const method}
   { Return the size of the vector (i.e. n) }     
   \classmember{V[i]}{(const) method}
   { Return a reference on the component i of the vector }
  
 \classmember{V *= a}{operator}
   { Multiply the vector with the scalar a. V contains the result. }
  
 \classmember{V /= a}{operator}
   { Divide the vector with the scalar a. V contains the result. }
  
 \classmember{V += W}{operator}
   { Add vector W to vector V. V contains the result. }
  
 \classmember{V -= W}{operator}
   { Substract vector W to vector V. V contains the result. }
  
 \classmember{V * a}{operator}
   { Multiply V by the scalar a }
  
 \classmember{a * V}{operator}
   { Multiply V by the scalar a }
  
 \classmember{V / a}{operator}
   { Divide V by the scalar a }
  
 \classmember{V + W}{operator}
   { Add V and W}
  
 \classmember{V - W}{operator}
   { Substract W to V}
  
 \classmember{-V}{operator}
   { Gives the opposite of V}
  
 \classmember{+V}{operator}
   { Gives  V}
  
 \classmember{vect\_sp(V,W)}{function}
   { Scalar product between V and W}
  
   \end{classmembersdescription} \end{classdescription} 
 \begin{functionsdescription}{ Generic functions on vectors}
  \begin{classmembersdescription} 
 \classmember{o $<<$ V}{operator}
   { Print V on the output stream o. For instance, cout $<<$ V;}
  
 \classmember{vect\_norm1(V)}{function}
   { Gives $\displaystyle \sum_{i=0..(n-1)} |V_i|$ }
  
 \classmember{vect\_norm2(V)}{function}
   { Gives $\displaystyle (\sum_{i=0..(n-1)} (V_i)^2)^{1/2}$ }
  
 \classmember{vect\_norminf(V)}{function}
   { Gives $\displaystyle \sup_{i=0..(n-1)} |V_i|$ }
  
 \classmember{vect\_dist1(V, W)}{function}
   { Gives $\displaystyle \sum_{i=0..(n-1)} |V_i - W_i|$ }
  
 \classmember{vect\_dist2(V, W)}{function}
   { Gives $\displaystyle (\sum_{i=0..(n-1)} |V_i - W_i|^2)^{1/2}$ }
  
 \classmember{vect\_dist2(V, W)}{function}
   { Gives $\displaystyle \sup_{i=0..(n-1)} |V_i - W_i|$ }
  
  \end{classmembersdescription} \end{functionsdescription} 
 \begin{classdescription}{PT}
   \begin{classdeclaration}
   \classdecl{PT$<$VECT$>$ pt;}
             { A point built with the vector class VECT.}
   \classdecl{PT$<$VECT$>$ pt(V);}
     { A point built with the vector class VECT and initialized with OV.}
   \classdecl{PT$<$VECT$>$ pt(p, V);}
     { A point built with the vector class VECT and initialized with p+V.}
   \classdecl{PT$<$VECT$>$ pt(n);}
     { A point built with the vector class VECT and
       initialized with VECT(n). }  
   \end{classdeclaration}
   \classdesc{ For any class of vector VECT, the class PT$<$VECT$>$ 
               represent the corresponding class of point.}
   \end{classdescription} 
 \begin{functionsdescription}{ Generic functions on points}
  \begin{classmembersdescription} 
 \classmember{vector\_from(A, B)}{function}
   { Return the vector AB, where A and B are some points. }
  
 \classmember{vector\_from(A, B, V)}{function}
   { Compute in V the vector AB, where A and B are some points.}
  
  \end{classmembersdescription} \end{functionsdescription} 
  \end{filedescription} 
 \begin{filedescription}{ Basic GEOmetric Tool }
             { Description of convex structure }
             { bgeot\_convex\_structure.h }
    \begin{filepresentation}
      This unit deals with the description of the structures of convexes.
      This means the number of vertex, of faces, types of faces ...
    \end{filepresentation}
  
 \begin{classdescription}{convex\_structure}
   \begin{classdeclaration}
   \classdecl{convex\_structure cv;}{undefined convex structure.}
   \end{classdeclaration}
   \classdesc{ Structure of a convex.  This class 
       is not to be manipulate by itself. Use pconvex\_structure and
       the functions written to produce the convex structures from
       classicals convexes (simplexes, polygonals ...). The reason is
       that there is no need for having more than one convex structure
       for the same type of convex.  }
    \begin{classmembersdescription} 
 \classmember{nb\_faces()}{const method}{Number of faces. }
  
 \classmember{dim()}{const method}{Dimension of convex.}
  
 \classmember{nb\_points()}{const method}{Number of vertexes.}
  
 \classmember{nb\_points\_of\_face(i)}{const method}
 {Number of vertexes of face i.}
  
 \classmember{ind\_points\_of\_face(i)}{const method}
 { Gives an array of the indexes of the vertexes of face i into
  the array of the vertexes of the convex. ind\_points\_of\_face(i)[j]
  is the vertex j of the face i.}
  
 \classmember{faces\_structure()}{const method}
 { Gives a pointer array on the structures of the faces.
   faces\_structure()[i] is a pointer on the structure of the face i.}
  
 \end{classmembersdescription} \end{classdescription}
 \begin{functionsdescription}{ Functions on convex structures }
  \begin{classmembersdescription} 
 \classmember{o $<<$ cvs}{operator}
 { Print the details of the convex structure cvs to the output stream o.
   For debuging purpose.}
  
 \classmember{simplex\_structure(d)}{function}
 { Gives a pointer on the structures of a simplex of dimension d.}
  
 \classmember{parallelepiped\_structure(d)}{function}
 { Gives a pointer on the structures of a parallelepiped of dimension d.}
  
 \classmember{polygon\_structure(n)}{function}
 { Gives a pointer on the structures of a polygon with n vertex.}
  
 \classmember{convex\_product\_structure(pcvs1, pcvs2)}{function}
 { Gives a pointer on the structures of a convex which is the direct
   product of the convexes represented by *pcvs1 and *pcvs2.}
  
 \classmember{prism\_structure(d)}{function}
 { Gives a pointer on the structures of a prism of dimension d.
   i.e. the direct product of a simplex of dimension d-1 and a segment.}
  
  \end{classmembersdescription} \end{functionsdescription} \end{filedescription} 
 \begin{filedescription}{ Basic GEOmetric Tool }
             { Basic description of Finite Element Interpolation }
             { bgeot\_fem\_interpolation.h }
    \begin{filepresentation}
      This unit deals with the description of finite element, at the
      level of the description of nodes, basic functions, ...
    \end{filepresentation}
  
 \begin{classdescription}{ddl\_type}
   \begin{classdeclaration}
   \classdecl{ddl\_type d;}{ type of ddl.}
   \end{classdeclaration}
   \classdesc{ the ddl type is either \begin{alltt} LAGRANGE, NORM\_DERIVATIVE,
               DERIVATIVE or MEAN\_VALUE. \end{alltt} $\;$ }
  \end{classdescription} 
 \begin{classdescription}{node\_description}
   \begin{classdeclaration}
   \classdecl{node\_description nd;}{ undefined node description.}
   \end{classdeclaration}
   \classdesc{ Of type std::vector$<$ddl\_type$>$. This class 
       is not to be manipulate by itself. Use pnode\_description and
       the functions written to produce the descriptions from the
       basic descriptions. }
   \end{classdescription} 
 \begin{functionsdescription}{ Functions on node description }
  \begin{classmembersdescription} 
 \classmember{lagrange\_node()}{function}
 { Description of a unique node of lagrange type (value at the node). }
  
 \classmember{derivative\_node(i)}{function}
 { Description of a unique node of derivative type (a derivative
    at the node). }
  
 \classmember{norm\_derivative\_node(i,j)}{function}
 { Description of a unique node of normal derivative type
   (normal derivative at the node, regarding a face). }
  
 \classmember{mean\_value\_node(i,j)}{function}
 { Description of a unique node of mean value type. }
  
 \classmember{product\_node(pnd1, pnd1)}{function}
 { Product description of the descriptions *pnd1 and *pnd2. }
  
  \end{classmembersdescription} \end{functionsdescription} 
 \begin{classdescription}{fem\_interpolation}
   \begin{classdeclaration}
   \classdecl{fem\_interpolation nd;}{ undefined fem interpolation
              description.}
   \end{classdeclaration}
   \classdesc{ Describe a finite element method on a reference element.
       This class 
       is not to be manipulate by itself. Use pfem\_interpolation and
       the functions written to produce the descriptions from the
       basic descriptions. }
  \begin{classmembersdescription}
  \classmember{nb\_dof()}{const method}{Number of degrees of fridom. }
  \classmember{nodes()}{const method}
     {Gives the array of nodes. nodes()[i] is the ith node }
  \classmember{nodes\_types()}{const method}
     {Gives the array of pointer on node description. }
  \classmember{structure()}{const method}
     {Gives the convex structure of the reference element. }
  \classmember{node\_convex()}{const method}
     {Gives the convex of the reference element. }
  \classmember{base()}{const method}
     {Gives the array of basic functions. }
  \end{classmembersdescription}
   \end{classdescription} 
 \begin{functionsdescription}{ Functions on convex structures }
  \begin{classmembersdescription} 
 \classmember{PK\_fem\_interpolation(n,k)}{function}
 { Description of the classical finite element Pk on simplex of
   dimension n.}
  
 \classmember{product\_interpolation(pi1, pi2)}{function}
 { Description of the tensorial product of the two elements *pi1, *pi2.}
  
 \classmember{P1\_nonconforming\_interpolation()}{function}
 { Description of the P1 non conforming finite element on triangles. }
  
  \end{classmembersdescription} \end{functionsdescription} 
 \begin{fileinfocomp}
   \comitem{General finite element method}
   A general finite element method is described by the set of the
   three following things:
   \begin{itemize}
      \item An element $T$ (geometric figure, polyhedric and convex),
      \item A functional vectorial space $V$, of finite dimension $n_g$,
      \item A set of $n_g$ linear functional
            $$ l_i : V \longrightarrow \Reel, \ \ \ i = 1..n_g. $$ 
   \end{itemize}
   Very often, each linear functional $l_i$ will be associated with
   a node $a^i$, which is a particular point of $T$. \\
   The basic functions of the finite element are the functions
   $\varphi_i \in V$ which satisfy
   $$ l_i(\varphi_j) = \delta_{ij}, i,j = 1..n_g. $$ 
   The finite element is said "univalent" when the set of basic functions
   are uniquely defined. \\
   Often $V$ is a space of polynomials, but not always. \\
   
   \comitem{Considered finite element methods}
   The finite element methods treaten in {\sc Getfem++}, are
   the methods satisfying the following assumptions :
  
   \begin{itemize}
     \item the method is equivalent throw a polynomial geometric
       transformation to a method defined on a reference element.
       This means that there exist a reference element $\overline{T}$, and
       a transformation
       $$ \begin{array}{rcl} \tau : \overline{T} &\longrightarrow& T, \\
          \overline{x} &\longmapsto& x, \end{array} $$
       which is polynomial.
     \item $\overline{V}$ the functional vectorial space defined on 
     $\overline{T}$ is a set of real scalar functions.
     $$ \overline{\varphi_i} : \overline{T} \longrightarrow \Reel. $$
     This means that,
     for the moment, vectorial finite element methods can only be built
     as direct product of scalar finite element methods.
     The basic functions of the real finite element, i.e. defined on the
     real element $T$, are
     $$ \varphi_i(x) = \overline{\varphi_i}(\tau(\overline{x})). $$
   \end{itemize}
  \end{fileinfocomp} \end{filedescription} 
 \begin{filedescription}{ Basic GEOmetric Tool }
             { Description of Geometric transformations }
             { bgeot\_geometric\_trans.h }
    \begin{filepresentation}
      Class  which  is  the  description  of  a  geometric transformation
      between a reference element and a real element. This transformation
      is represented by a vector of polynomials.
    \end{filepresentation}
  
 \begin{classdescription}{geometric\_trans}
   \begin{classdeclaration}
   \classdecl{geometric\_trans gt;}{undefined class.}
   \end{classdeclaration}
   \classdesc{ Description     of     a     geometric    transformation.
               Géometric  nodes  and  vector  of polynomials. This class 
       is not  to be  manipulate  by itself.  Use pgeometric\_trans  and
       the   functions   written   to   produce   the   basic  geometric
       transformations.  }
    \begin{classmembersdescription} 
 \classmember{dim()}{const method}
        { Dimension of the reference element. }
  
 \classmember{is\_linear()}{const method}
        { True if the transformation is linear (affine in fact). }
  
 \classmember{nb\_points()}{const method}
        { Number of geometric nodes. }
  
 \classmember{structure()}{const method}
        { Structure of the reference element. }
  
 \classmember{poly\_vector()}{const method}
        { Gives the vector of polynomials representing the
          transformation. }
  
 \classmember{poly\_vector()}{const method}
        { Gives the array of geometric nodes. }
  
 \classmember{normals()}{const method}
        { Gives the array of the normals to faces. }
  
 \end{classmembersdescription} \end{classdescription}
 \begin{functionsdescription}{ Functions on geometric transformations }
  \begin{classmembersdescription} 
 \classmember{simplex\_trans(n, r)}{const method}
        { Gives the classical transformation of degree r in dimension n. }
  
 \classmember{convex\_product\_trans(pgt1, pgt2)}{const method}
        { Gives the tensorial product of transformations *pgt1 and *pgt2. }
  
 \classmember{linea\_product\_trans(pgt1, pgt2)}{const method}
        { Gives a product of transformations *pgt1 and *pgt2 which
          remains linear if *pgt1 and *pgt2 are. }
  
 \end{classmembersdescription}
   \end{functionsdescription} 
 \begin{fileinfocomp}
   \comitem{Description of the geometry}
     Let $T \in\ \Reel^P$ be a real element and
     $\overline{T} \in\ \Reel^N$ be a reference element, with $P >= N$. \\
     The geometric nodes of $\overline{T}$ are the points
     $\overline{a}^i \in\ \Reel^N$, for $i = 0 .. n_g-1$, and the
     corresponding (via the geometric
     transformation) nodes of $T$ are the points $a^i \in\ \Reel^P$. 
   \comitem{Geometric transformation}
     The geometric transformation is the application
     $$ \begin{array}{rl}
        \tau : \overline{T} & \longrightarrow \ T, \\
               \overline{x} & \longmapsto \ \ x,
     \end{array} $$
     which should be a diffeomorphism between $\overline{T}$ and $T$. It
     is assumed that there exists a polynomial vector
     $$ \underline{\cal N}(\overline{x})
        = \left({\cal N}_i(\overline{x})\right)_i, \ \ i = 0 .. n_g-1, $$
     defined on $\overline{T}$ of size $n_g$, such that the transformation
     $\tau$ can be written
     $$ \tau(\overline{x}) = \sum_{i = 0}^{n_g-1} {\cal N}_i(\overline{x})
     a^i. $$
     Denoting by
     $$ \udl{\udl{a}} = (a^0; a^1; ...;a^{n_g-1}), $$
     The matrix in which each column is a geometric node of $T$,
     the transformation $\tau$ can be written as
     $$ \tau(\overline{x}) = \udl{\udl{a}} \ 
        \underline{\cal N}(\overline{x}). $$
   \comitem{Gradient of the transformation}
     The gradient of the transformation is
     $$ \nabla \tau(\overline{x}) = 
     \left( \Frac{\partial \tau_i}{\partial \overline{x}_j} \right)_{ij}
     = \left( \sum_{l = 0}^{n_g-1}a^l_i
     \Frac{\partial {\cal N}_l(\overline{x})}{\partial \overline{x}_j}
     \right)_{ij} = \udl{\udl{a}}\ \nabla
     \underline{\cal N}(\overline{x}), $$
     Remark : $\udl{\udl{a}}$ is a $P \times n_g$ matrix,
       $\nabla \underline{\cal N}(\overline{x})$ is a $n_g \times N$
       matrix, and thus $\nabla \tau(\overline{x})$ is a $P \times N$
       matrix.
   \comitem{Inverse transformation and pseudo-inverse}
  \end{fileinfocomp} \end{filedescription} 
 \begin{filedescription}{ Basic GEOmetric Tool }
             { Exact integration of polynomials. }
             { bgeot\_poly\_integration.h }
    \begin{filepresentation}
      This unit deals with the exact integration of polynomials of
      several variables on a reference element.
    \end{filepresentation}
  
 \begin{classdescription}{poly\_integration}
   \begin{classdeclaration}
   \classdecl{poly\_integration pi;}{undefined class.}
   \end{classdeclaration}
   \classdesc{ Description of an exact integration of polynomials.
       This class 
       is not to be manipulate by itself. Use ppoly\_integration and
       the functions written to produce the basic descriptions.  }
    \begin{classmembersdescription} 
 \classmember{dim()}
        {const method}{Dimension of reference convex.}
  
 \classmember{structure()}
        {const method}{Structure of reference convex.}
  
 \classmember{int\_poly(P)}{const method}
   { Evaluate the integral of the polynomial P on the reference
     element.}
  
 \classmember{int\_poly\_on\_face(P, f)}{const method}
  { Evaluate the integral of the polynomial P on the face f of the
    reference element.}
  
 \end{classmembersdescription} \end{classdescription}
 \begin{functionsdescription}{ Functions on poly integration}
  \begin{classmembersdescription} 
 \classmember{simplex\_poly\_integration(n)}{function}
  { Give the exact integration method on a simplex of dimension n.}
  
 \classmember{convex\_product\_poly\_integration(ppi1, ppi2)}
  {function}
  { Give the exact integration method corresponding to the tensorial
    product of *pp1 and *pp2.}
  
 \classmember{parallelepiped\_poly\_integration(n)}{function}
  { Give the exact integration method on a parallelepiped of dimension n.}
  
 \classmember{parallelepiped\_poly\_integration(n)}{function}
  { Give the exact integration method on a prism of dimension n.}
  
  \end{classmembersdescription} \end{functionsdescription} \end{filedescription} 
 \begin{filedescription}{ Basic GEOmetric Tool }
             { Approximate integration of polynomials. }
             { bgeot\_approx\_integration.h }
    \begin{filepresentation}
      This unit deals with the approximate integration of polynomials of
      several variables on a reference element.
    \end{filepresentation}
  
 \begin{classdescription}{approx\_integration}
   \begin{classdeclaration}
   \classdecl{approx\_integration pi;}{undefined class.}
   \end{classdeclaration}
   \classdesc{ Description of an approximate integration of polynomials.
       This class 
       is not to be manipulate by itself. Use papprox\_integration and
       the functions written to produce the basic descriptions.  }
    \begin{classmembersdescription} 
 \classmember{dim()}
        {const method}{Dimension of reference convex.}
  
 \classmember{nb\_points\_on\_convex()}{const method}
      {Number of integration nodes on the reference element.}
  
 \classmember{nb\_points\_on\_face(f)}{const method}
      {Number of integration nodes on the face f of the 
       reference element.}
  
 \classmember{structure()}{const method}
      {Structure of the reference element.}
  
 \classmember{integration\_points()}{const method}
      {Gives an array of integration nodes.}
  
 \classmember{point(i)}{const method}
      {Gives the integration node i on the reference element.}
  
 \classmember{point\_on\_face(f, i)}{const method}
      {Gives the integration node i of the face f.}
  
 \classmember{integration\_coefficients()}{const method}
      {Gives an array of the integration coefficients.}
  
 \classmember{coeff(i)}{const method}
      {Gives the integration coefficient corresponding to node i.}
  
 \classmember{coeff\_on\_face(f,i)}{const method}
      {Gives the integration coefficient corresponding to
       node i of face f.}
  
 \end{classmembersdescription} \end{classdescription}
 \begin{functionsdescription}{ Functions on poly integration}
  \begin{classmembersdescription} 
 \classmember{Gauss\_approx\_integration(nbpt)}{function}
  { Give the Gauss approximate integration method in dimension 1 with
    nbpt integration nodes.}
  
 \classmember{Newton\_Cotes\_approx\_integration(n,k)}{function}
  { Give the Newton Cotes approximate integration method in simplex of
    dimension n
    and of degree k (corresponds to lagrange interpolation).}
  
 \classmember{convex\_product\_approx\_integration(pai1, pai2)}
  {function}
  { Give the approximate integration method corresponding to the
    tensorial product of *pai1 and *pai2.}
  
  \end{classmembersdescription} \end{functionsdescription} \end{filedescription} 
 \begin{librarydescription}{ GEneric Tool for Finite Element Methods }
   The Getfem library is ...
   \\ \\
  \end{librarydescription} 
 \begin{filedescription}{ GEneric Tool for Finite Element Methods }
             { Description of a complete finite element method on a
               element }
             { getfem\_fem.h }
    \begin{filepresentation}
      This unit deals with the description of a finite element method
      being the set of a interpolation method, a geometric transformation
      and a integration method.
    \end{filepresentation}
   
 \begin{classdescription}{fem}
   \begin{classdeclaration}
   \classdecl{fem F;}{undefined fem structure.}
   \end{classdeclaration}
   \classdesc{ Description of a finite element method.  This class 
       is not to be manipulate by itself. Use pfem and
       the functions written to produce those descriptions.  }
    \begin{classmembersdescription} 
 \end{classmembersdescription} \end{classdescription}
 \begin{functionsdescription}{ Functions on fem descriptions }
  \begin{classmembersdescription} 
 \classmember{fem\_exact\_integration(pf, pg, pi)}{function}
 { Gives a pointer on the structures describing the finite element method
   determined by the interpolation method pf of type
   bgeot::pfem\_interpolation, the geometric transformation pg of type 
   bgeot::pgeometric\_trans and the integration method pi of type 
   bgeot::ppoly\_integration. }
  
 \classmember{fem\_approx\_integration(pf, pg, pi)}{function}
 { Gives a pointer on the structures describing the finite element method
   determined by the interpolation method pf of type
   bgeot::pfem\_interpolation, the geometric transformation pg of type 
   bgeot::pgeometric\_trans and the integration method pi of type 
   bgeot::papprox\_integration. }
  
 \classmember{fem\_exact\_linear\_PK(n, k)}{function}
 { Gives a pointer on the structures describing the classical P$_K$ 
   finite element method of degree K on the simplex of dimension n,
   with linear geometric transformation and exact integration. }
  
 \classmember{fem\_P1\_nonconforming()}{function}
 { Gives a pointer on the structures describing the non conforming P$_1$ 
   finite element method on the triangle,
   with linear geometric transformation and exact integration. }
  
  \end{classmembersdescription} \end{functionsdescription} \end{filedescription} 
 \begin{filedescription}{ GEneric Tool for Finite Element Methods }
             { Description of an elementary matrix. }
             { getfem\_mat\_elem\_type.h }
    \begin{filepresentation}
      This unit deals with the description of elementary matrices.
    \end{filepresentation}
   
 \begin{classdescription}{mat\_elem\_type}
   \begin{classdeclaration}
   \classdecl{mat\_elem\_type met;}{undefined structure.}
   \end{classdeclaration}
   \classdesc{ Description of an elementary matrix.  This class 
       is not to be manipulate by itself. Use pmat\_elem\_type and
       the functions written to produce those descriptions.  }
    \begin{classmembersdescription} 
 \end{classmembersdescription} \end{classdescription}
 \begin{functionsdescription}{ Functions on elementary matrix descriptions }
  \begin{classmembersdescription} 
 \classmember{mat\_elem\_base(pi)}{function}
 { Gives a pointer on the structures describing the elementary matrix
   which compute the integral of the basic functions described by pi.
    pi is of type bgeot::pfem\_interpolation. }
  
 \classmember{mat\_elem\_grad(pi)}{function}
 { Gives a pointer on the structures describing the elementary matrix
   which compute the integral of the gradient of the basic functions
    described by pi. pi is of type bgeot::pfem\_interpolation. }
  
 \classmember{mat\_elem\_hessian(pi)}{function}
 { Gives a pointer on the structures describing the elementary matrix
   which compute the integral of the hessian of the basic functions
    described by pi. pi is of type bgeot::pfem\_interpolation. }
  
 \classmember{mat\_elem\_product(pet1, pet2)}{function}
 { Gives a pointer on the structures describing the elementary matrix
   which compute the integral of product of the integrals described by
   *pet1 and *pet2. }
  
  \end{classmembersdescription} \end{functionsdescription} \end{filedescription} 
 \begin{filedescription}{ GEneric Tool for Finite Element Methods }
             { Meshes for computation }
             { getfem\_mesh.h }
    \begin{filepresentation}
      This unit define the principal class of meshes for the computation
      of pde problems.
    \end{filepresentation}
  
 \begin{classdescription}{getfem\_mesh}
   \begin{classdeclaration}
   \classdecl{getfem\_mesh  M(n);}{ mesh in dimension n .}
   \classdecl{getfem\_mesh  M;}{ mesh with undefined dimension.
      The first point added to the mesh defines the dimension. }
   \end{classdeclaration}
   \classdesc{Describe a mesh for the computation of pde problems. This
      mesh is able to be link with classes which define computation
      methods. }
    \begin{classmembersdescription} 
 \classmember{add\_point(pt)}{method}
        { Add the point pt to the mesh and return the index of the
          point. If the point is to close to an existing point, the
          function do not add the point and return the index of the
          already existing point. pt should be of type base\_node.}
  
 \classmember{nb\_points()}{const method}
        { Gives the number of points in the mesh. }
  
 \classmember{sup\_point(i)}{method}
        { Delete the point of index i from the mesh. }
  
 \classmember{swap\_points(i, j)}{method}
        { Swap the indexes of points of index i and j in the whole
          structure. }
  
 \classmember{search\_points(pt)}{const method}
        { Search if the point pt is in (or approximatively in)
          the mesh, and return the index of the point, or
          size\_type(-1) if not found. }
  
 \classmember{add\_convex(cv)}{method}
        { Add a convex to the mesh. cv is of type 
          bgeot::convex$<$base\_node, PT\_TAB$>$. Return the index
          of the convex in the mesh. }
  
 \classmember{add\_convex(cvs, it)}{method}
        { Add a convex to the mesh. cvs is of type 
          bgeot::convex\_structure and "it" is an iterator on a list
          of indexes of points. Return the index
          of the convex in the mesh.}
  
 \classmember{add\_convex\_by\_points(cvs, it)}{method}
        { Add a convex to the mesh. cvs is of type 
          bgeot::convex\_structure and "it" is an iterator on a list
          of points of type base\_node. Return the index
          of the convex in the mesh.}
  
 \classmember{add\_simplex(dim, it)}{method}
        { Add a simplex of dimension dim to the mesh. 
          "it" is an iterator on a list of indexes of the points.
          Return the index of the convex in the mesh.}
  
 \classmember{add\_simplex\_by\_points(dim, it)}{method}
        { Add a simplex of dimension dim to the mesh. 
          "it" is an iterator on a list of points of type base\_node.
          Return the index of the convex in the mesh.}
  
 \classmember{add\_parallelepiped(dim, it)}{method}
        { Add a parallelepiped of dimension dim to the mesh. 
          "it" is an iterator on a list of indexes of the points.
          Return the index of the convex in the mesh.}
  
 \classmember{add\_parallelepiped\_by\_points(dim, it)}{method}
        { Add a parallelepiped of dimension dim to the mesh. 
          "it" is an iterator on a list of points of type base\_node.
          Return the index of the convex in the mesh.}
  
 \classmember{add\_parallelepiped\_by\_points(dim, orh, it)}
        {method}{ Add a parallelepiped of dimension dim to the
          mesh. org is the point of type base\_node representing
          the origine and "it" is an iterator on a list of
          vectors of type base\_vector.
          Return the index of the convex in the mesh.}
  
 \classmember{sup\_convex(i)}{method}
        { Delete the convex of index i from the mesh.}
  
 \classmember{swap\_convex(i,j)}{method}
        { Swap the indexes of the convex of indexes i and j 
          in the whole structure.}
  
  \end{classmembersdescription} \end{classdescription} 
  \end{filedescription} 
 \begin{filedescription}{ GEneric Tool for Finite Element Methods }
             { Description of a finite element method on a mesh}
             { getfem\_mesh\_fem.h }
    \begin{filepresentation}
      This unit define the structure which describe a finite element
      method linked to a particular mesh of type getfem\_mesh.
    \end{filepresentation}
  
 \begin{classdescription}{boundary\_description}
   \begin{classdeclaration}
   \classdecl{boundary\_description  b;}{ Boudary with no element.}
   \end{classdeclaration}
   \classdesc{Describe a boundary as a list of faces of elements. }
    \begin{classmembersdescription} 
 \classmember{add\_elt(i, f)}{method}
        { Add a boudary element from the face f of the convex of index
          i of the mesh.}
  
 \classmember{sup\_elt(i, f)}{method}
        { Delete a boudary element which is the face f of the convex of 
          index i of the mesh.}
  
 \classmember{sup\_convex(i)}{method}
        { Delete all boudary element linked with the convex of 
          index i of the mesh.}
  
 \classmember{faces\_of\_convex(i)}{const method}
        { Gives in a structure dal::bit\_vector all the faces of convex
          of index i in the boundary.}
  
  \end{classmembersdescription} \end{classdescription} 
 \begin{classdescription}{mesh\_fem}
   \begin{classdeclaration}
   \classdecl{mesh\_fem  mf(me);}{ Fem descritpion linked to the mesh me.}
   \end{classdeclaration}
   \classdesc{Describe a finite element method linked to a mesh. }
    \begin{classmembersdescription} 
 \classmember{convex\_index()}{const method}
        { Gives in a structure dal::bit\_vector all convexes of the
          mesh where a finite element is defined.}
  
 \classmember{linked\_mesh()}{const method}
        { Gives a pointer to the linked mesh of type getfem\_mesh.}
  
 \classmember{set\_finite\_element(i, pf)}{method}
        { Set on the convex of index i the finite element method
          with the description pf which is of type pfem.}
  
 \classmember{set\_finite\_element(bv, pf)}{method}
        { Set on all the convexes of indexes in bv, which is of type
          dal::bit\_vector, the finite element method
          with the description pf which is of type pfem.}
  
 \classmember{mat\_elem(pm, t, i)}{method}
        { Compute the elementary matrix of type pm (pmat\_elem\_type)
           on convex of index i. The result is in t (base\_tensor). }
  
 \classmember{mat\_elem\_on\_face(pm, t, i, f)}{method}
        { Compute the elementary matrix of type pm (pmat\_elem\_type)
           on the face f of the convex of index i.
           The result is in t (base\_tensor). }
  
 \classmember{mat\_elem(me, t, i)}{method}
        { Compute the elementary matrix ofclassical type me
          (classical\_mat\_elem)
           on convex of index i. The result is in t (base\_tensor). }
  
 \classmember{mat\_elem\_on\_face(me, t, i)}{method}
        { Compute the elementary matrix of classical type me
          (classical\_mat\_elem)
           on the face f of the convex of index i.
           The result is in t (base\_tensor). }
  
 \classmember{ind\_dof\_of\_element(i)}{method}
        { Gives an array of the degrees of freedom of the element
           of the convex of index i. }
  
 \classmember{nb\_dof\_of\_element(i)}{method}
        { Gives the number of  degrees of freedom of the element
           of the convex of index i. }
  
 \classmember{point\_of\_dof(cv, i)}{const method}
        { Gives the point (base\_node)  cooresponding to the 
          degree of freedom i  of the element of index cv. }
  
 \classmember{point\_of\_dof(i)}{const method}
        { Gives the point (base\_node)  cooresponding to the 
          degree of freedom with global index i. }
  
 \classmember{nb\_dof()}{method}
        { Gives the total number of degrees of freedom. }
  
 \classmember{add\_boudary\_elt(b, i, f)}{method}
        { Add to the boundary b the face f of the element i. }
  
 \classmember{is\_convex\_on\_boudary(i, b)}{method}
        { Says whether or not element i is on the boundary b. }
  
  \end{classmembersdescription} \end{classdescription} 
  \end{filedescription} 

\end{document}
